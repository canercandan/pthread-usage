<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr"><head><title>Initiation à la programmation multitâche en C avec Pthreads - Club d'entraide des développeurs francophones</title>


  
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <meta name="generator" content="developpez-com">
  <meta name="description" content="Initiation à la programmation multitâche en C avec Pthreads">
  <meta name="keywords" content="c, langage, threads, pthreads, pthreads-win32, LinuxThreads, programmation, multithreads, multithreadé, multitâche, posix">
  <meta name="MS.LOCALE" content="fr-FR">
  <script src="pthread_init_files/fonctions-kit.js" type="text/javascript"></script>
  <link rel="stylesheet" type="text/css" href="pthread_init_files/mainstyle-xhtml.css">
  <link rel="stylesheet" type="text/css" media="print" href="pthread_init_files/printer-xhtml.css">
  <link rel="stylesheet" type="text/css" media="screen" href="pthread_init_files/article.css">
	<meta name="author" content="Franck Hecht">
	<meta name="MSN_TopicType" content="Whitepaper">
	<meta name="MSN_PublishDate" content="11/04/2007 12:00:00 PM">
	<meta name="MSN_RevisedDate" content="01/01/1970 01:00:00 AM">
	<meta name="MSN_UserRating" content="100 %"></head><body xml:lang="fr"> <table cellspacing="5" width="100%">
  <tbody><tr>
    <td align="center">
     <table cellpadding="0" cellspacing="0" width="100%">
     <tbody><tr><td>
      <table cellspacing="0" width="100%">
      <tbody><tr>
        <td>
          <a href="http://www.developpez.com/"><img src="pthread_init_files/logo.gif" alt="Accueil"></a>
        </td>
        <td align="center" valign="middle">
     <span class="cachee">
	  <!--JavaScript Tag // Tag for network 224: Hi-Media France // Website: zzz - developpez.com -->
     <script type="text/javascript"><!--
     document.write('<scr'+'ipt language="javascript1.1"     src="http://adserver.adtech.de/addyn|3.0|224|1409132|0|1|ADTECH;loc=100;target=_blank; grp=1;misc='+new	  Date().getTime()+'"></scri'+'pt>');
     //-->
     </script><script style="display: none;" language="javascript1.1" src="pthread_init_files/addyn3"></script><noscript><div><a
href="http://adserver.adtech.de/adlink|3.0|224|1409132|0|1|ADTECH;loc=300;grp=1"><img
src="http://adserver.adtech.de/adserv|3.0|224|1409132|0|1|ADTECH;loc=300;grp=1"
alt="" /></a></div></noscript>
     <!-- End of JavaScript Tag -->
     </span>
        </td>
      </tr>
      </tbody></table>
      <table cellspacing="0" width="100%">
      <tbody><tr>
          <td class="tdha"></td>
          <td valign="top">
	     <div class="cachee">
             <form method="get" action="http://www.google.com/custom">
             <div><b>Rechercher:</b>
             <input name="q" size="20" maxlength="255" value="" type="text">
             <input name="sa" value="Go" type="submit"><br>
             <input name="cof" value="L:http://www.developpez.com/template/logo.gif;AH:center;GL:0;S:http://www.developpez.com;AWFID:466bd8f66d98f56f;" type="hidden">
             <input name="domains" value="developpez.com;developpez.net" type="hidden">
             <input name="sitesearch" value="developpez.com" checked="checked" type="radio"><span class="dev">sur developpez.com</span>
             <input name="sitesearch" value="developpez.net" type="radio"><span class="dev">sur les forums</span>
             </div></form>
	     </div>
          </td>
          <td align="right">
             <span class="cachee">
              <a href="http://www.developpez.net/forums/index.php" onclick="window.open(this.href); return false;" class="ntdrub">Forums</a>&nbsp;|&nbsp;<a href="http://general.developpez.com/cours/" class="ntdrub">Tutoriels</a>&nbsp;|&nbsp;<a href="http://general.developpez.com/faq/" class="ntdrub">F.A.Q's</a>&nbsp;|&nbsp;<a href="http://club.developpez.com/redaction/" class="ntdrub">Participez</a>&nbsp;|&nbsp;<a href="http://www.developpez.com/hebergement/" class="ntdrub">Hébergement</a>&nbsp;|&nbsp;<a href="http://club.developpez.com/contacts/" class="ntdrub">Contacts</a>
             </span>
          </td>
          <td class="tdha"></td>
      </tr>
      <tr><td class="tdhb"></td></tr>
      </tbody></table>
    </td>
  </tr>
  <tr>
    <td>
    <table class="cachee" cellpadding="0" cellspacing="0" width="100%">
    <tbody><tr class="bleufo">
      <td class="iongl"><img src="pthread_init_files/begh.gif" alt=""></td>
      <td class="bgmarron"><a href="http://blog.developpez.com/?blog=18" class="ntdrub">Club</a></td>
      <td class="iongl"><img src="pthread_init_files/bdh_003.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bgh_002.gif" alt=""></td>
      <td class="bgmarron"><a href="http://emploi.developpez.com/" class="ntdrub">Emploi</a></td>
      <td class="iongl"><img src="pthread_init_files/bdh_003.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bgh_002.gif" alt=""></td>
      <td class="bgmarron"><a href="http://blog.developpez.com/" class="ntdrub">Blogs</a></td>
      <td class="iongl"><img src="pthread_init_files/bdh_003.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bgh_002.gif" alt=""></td>
      <td class="bgmarron"><a href="http://www.developpez.tv/" class="ntdrub">&nbsp;&nbsp;TV&nbsp;&nbsp;</a></td>
      <td class="iongl"><img src="pthread_init_files/bdh_003.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bgh_003.gif" alt=""></td>
      <td class="bgjaune"><a href="http://web.developpez.com/" class="ntdrub">Dév.&nbsp;Web</a></td>
      <td class="iongl"><img src="pthread_init_files/bdh.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bgh_003.gif" alt=""></td>
      <td class="bgjaune"><a href="http://php.developpez.com/" class="ntdrub">PHP</a></td>
      <td class="iongl"><img src="pthread_init_files/bdh.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bgh_003.gif" alt=""></td>
      <td class="bgjaune"><a href="http://xml.developpez.com/" class="ntdrub">XML</a></td>
      <td class="iongl"><img src="pthread_init_files/bdh.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bgh_003.gif" alt=""></td>
      <td class="bgjaune"><a href="http://python.developpez.com/" class="ntdrub">Python</a></td>
      <td class="iongl"><img src="pthread_init_files/bdh.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bgh_003.gif" alt=""></td>
      <td class="bgjaune"><a href="http://general.developpez.com/cours/" class="ntdrub">Autres</a></td>
      <td class="iongl"><img src="pthread_init_files/bdh.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bgh.gif" alt=""></td>
      <td class="bgvert"><a href="http://jeux.developpez.com/" class="ntdrub">2D-3D-Jeux</a></td>
      <td class="iongl"><img src="pthread_init_files/bdh_002.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bgh.gif" alt=""></td>
      <td class="bgvert"><a href="http://securite.developpez.com/" class="ntdrub">Sécurité</a></td>
      <td class="iongl"><img src="pthread_init_files/bdh_002.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bgh.gif" alt=""></td>
      <td class="bgvert"><a href="http://windows.developpez.com/" class="ntdrub">Windows</a></td>
      <td class="iongl"><img src="pthread_init_files/bdh_002.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bgh.gif" alt=""></td>
      <td class="bgvert"><a href="http://linux.developpez.com/" class="ntdrub">Linux</a></td>
      <td class="iongl"><img src="pthread_init_files/bdh_002.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bgh.gif" alt=""></td>
      <td class="bgvert"><a href="http://hardware.developpez.com/" class="ntdrub">PC</a></td>
      <td class="iongl"><img src="pthread_init_files/bdh_002.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bgh.gif" alt=""></td>
      <td class="bgvert"><a href="http://mac.developpez.com/" class="ntdrub">Mac</a></td>
      <td class="iongl"><img src="pthread_init_files/bdh_002.gif" alt=""></td>
   </tr>
   </tbody></table>
   </td></tr>
   <tr><td>
    <table class="cachee" cellpadding="0" cellspacing="0" width="100%">
  <tbody><tr>
      <td class="iongl"><img src="pthread_init_files/beg.gif" alt=""></td>
      <td class="bgmarron"><a href="http://www.developpez.com/" class="ntdrub">Accueil</a></td>
      <td class="iongl"><img src="pthread_init_files/bd_003.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bg_002.gif" alt=""></td>
      <td class="bgjaune"><a href="http://conception.developpez.com/" class="ntdrub">Conception</a></td>
      <td class="iongl"><img src="pthread_init_files/bd.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bg_002.gif" alt=""></td>
      <td class="bgjaune"><a href="http://java.developpez.com/" class="ntdrub">Java</a></td>
      <td class="iongl"><img src="pthread_init_files/bd.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bg_002.gif" alt=""></td>
      <td class="bgjaune"><a href="http://dotnet.developpez.com/" class="ntdrub">DotNET</a></td>
      <td class="iongl"><img src="pthread_init_files/bd.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bg_002.gif" alt=""></td>
      <td class="bgjaune"><a href="http://vb.developpez.com/" class="ntdrub">Visual&nbsp;Basic</a></td>
      <td class="iongl"><img src="pthread_init_files/bd.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bg.gif" alt=""></td>
      <td class="bgbleu"><a href="http://c.developpez.com/" class="narub">&nbsp;C&nbsp;</a></td>
      <td class="iongl"><img src="pthread_init_files/bd_002.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bg_002.gif" alt=""></td>
      <td class="bgjaune"><a href="http://cpp.developpez.com/" class="ntdrub">C++</a></td>
      <td class="iongl"><img src="pthread_init_files/bd.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bg_002.gif" alt=""></td>
      <td class="bgjaune"><a href="http://delphi.developpez.com/" class="ntdrub">Delphi</a></td>
      <td class="iongl"><img src="pthread_init_files/bd.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bg_002.gif" alt=""></td>
      <td class="bgjaune"><a href="http://office.developpez.com/" class="ntdrub">MS-Office</a></td>
      <td class="iongl"><img src="pthread_init_files/bd.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bg_002.gif" alt=""></td>
      <td class="bgjaune"><a href="http://sgbd.developpez.com/" class="ntdrub">SQL&nbsp;&amp;&nbsp;SGBD</a></td>
      <td class="iongl"><img src="pthread_init_files/bd.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bg_002.gif" alt=""></td>
      <td class="bgjaune"><a href="http://oracle.developpez.com/" class="ntdrub">Oracle</a></td>
      <td class="iongl"><img src="pthread_init_files/bd.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bg_002.gif" alt=""></td>
      <td class="bgjaune"><a href="http://4d.developpez.com/" class="ntdrub">&nbsp;4D&nbsp;</a></td>
      <td class="iongl"><img src="pthread_init_files/bd.gif" alt=""></td>
      <td class="iongl"><img src="pthread_init_files/bg_002.gif" alt=""></td>
      <td class="bgjaune"><a href="http://business-intelligence.developpez.com/" class="ntdrub">Business&nbsp;Intelligence</a></td>
      <td class="iongl"><img src="pthread_init_files/bed.gif" alt=""></td>
  </tr>
   </tbody></table>
   </td>
   </tr>
    <tr>
      <td class="trbleu">
      <table class="cachee bleufo" cellpadding="0" cellspacing="0">
       <tbody><tr>
       <td><img src="pthread_init_files/btg.gif" alt=""></td>
       <td class="intbt"><a href="http://www.developpez.net/forums/forumdisplay.php?f=7" class="narub">FORUMS&nbsp;C</a></td>
       <td><img src="pthread_init_files/btd.gif" alt=""></td>
       <td><img src="pthread_init_files/btg.gif" alt=""></td>
       <td class="intbt"><a href="http://c.developpez.com/faq/" class="narub">FAQs&nbsp;C</a></td>
       <td><img src="pthread_init_files/btd.gif" alt=""></td>
       <td><img src="pthread_init_files/btg.gif" alt=""></td>
       <td class="intbt"><a href="http://c.developpez.com/cours/" class="narub">TUTORIELS&nbsp;C</a></td>
       <td><img src="pthread_init_files/btd.gif" alt=""></td>
       <td><img src="pthread_init_files/btg.gif" alt=""></td>
       <td class="intbt"><a href="http://c.developpez.com/livres/" class="narub">LIVRES&nbsp;C</a></td>
       <td><img src="pthread_init_files/btd.gif" alt=""></td>
       <td><img src="pthread_init_files/btg.gif" alt=""></td>
       <td class="intbt"><a href="http://c.developpez.com/compilateurs/" class="narub">COMPILATEURS&nbsp;C</a></td>
       <td><img src="pthread_init_files/btd.gif" alt=""></td>
       <td><img src="pthread_init_files/btg.gif" alt=""></td>
       <td class="intbt"><a href="http://c.developpez.com/sources/" class="narub">SOURCES</a></td>
       <td><img src="pthread_init_files/btd.gif" alt=""></td>
       <td><img src="pthread_init_files/btg.gif" alt=""></td>
       <td class="intbt"><a href="http://gtk.developpez.com/" class="narub">GTK+</a></td>
       <td><img src="pthread_init_files/btd.gif" alt=""></td>
       </tr>
       </tbody></table>
     </td>
    </tr>
    <tr valign="top">
    <td class="fondart" valign="top">
    <table class="tbnoir" cellspacing="1" width="100%">
    <tbody><tr><td class="fondart">
<div class="divarticle">
		<br><h1>Initiation à la programmation multitâche en C avec Pthreads</h1><p class="dateArticle">Date de publication : 04/11/2007</p><p style="text-align: center;">
		Par
		<a class="auteur" href="http://www.developpez.net/forums/member.php?u=29006">Franck Hecht</a> <a class="homepage" href="http://franckh.developpez.com/"> (retour aux articles)</a> <a class="homepage" href="http://blog.developpez.com/index.php?blog=163">(Blog)</a><br>&nbsp;</p><div class="synopsis">
	Les threads permettent de créer des programmes multitâches, ce tutoriel vous 
	propose une approche par la pratique en partant d'un exemple unique !
</div>
	<br><a class="summaryIndent0" href="#LI">I. Introduction</a>
		

		
	

	<br><a class="summaryIndent0" href="#LII">II. Avant de commencer</a>
		

		



		



		



		

		

		
	

	<br><a class="summaryIndent0" href="#LIII">III. Qu'est-ce qu'un thread ?</a>
		

		
	

	<br><a class="summaryIndent0" href="#LIV">IV. Création et exécution des threads</a>
		

		<br><a class="summaryIndent1" href="#LIV-A">IV-A. pthread_create</a>
			
	
			



			

			
	
			

			

			

			
		
	

	<br><a class="summaryIndent0" href="#LV">V. Annulation et fin des threads</a>
		

		<br><a class="summaryIndent1" href="#LV-A">V-A. pthread_exit</a>
			

			



			
		

		<br><a class="summaryIndent1" href="#LV-B">V-B. pthread_cancel</a>
			

			



			

			

			<br><a class="summaryIndent2" href="#LV-B-1">V-B-1. pthread_setcancelstate</a>
				
				


				

				

				
			
		

		<br><a class="summaryIndent1" href="#LV-C">V-C. pthread_join</a>
			

			



			

			

			

			

			
		
	

	<br><a class="summaryIndent0" href="#LVI">VI. Mise en pratique</a>
		

		

		<br><a class="summaryIndent1" href="#LVI-A">VI-A. Code complet</a>
			

			



			
		

		<br><a class="summaryIndent1" href="#LVI-B">VI-B. Sortie du programme</a>
			

			



			

			
		

		<br><a class="summaryIndent1" href="#LVI-C">VI-C. Observations</a>
			

			
		
	

	<br><a class="summaryIndent0" href="#LVII">VII. Les mutex</a>
		

		



		

		<br><a class="summaryIndent1" href="#LVII-A">VII-A. pthread_mutex_lock</a>
			



			

			
		

		<br><a class="summaryIndent1" href="#LVII-B">VII-B. pthread_mutex_unlock</a>
			



			

			
		
	

	<br><a class="summaryIndent0" href="#LVIII">VIII. Mise en pratique</a>
		

		

		

		<br><a class="summaryIndent1" href="#LVIII-A">VIII-A. Code complet</a>
			

			



			
		

		<br><a class="summaryIndent1" href="#LVIII-B">VIII-B. Sortie du programme</a>
			

			



			

			
		

		<br><a class="summaryIndent1" href="#LVIII-C">VIII-C. Observations</a>
			

			
		
	

	<br><a class="summaryIndent0" href="#LIX">IX. Les conditions</a>
		

		



		

		

		

		<br><a class="summaryIndent1" href="#LIX-A">IX-A. pthread_cond_wait</a>
			



			

			
		

		<br><a class="summaryIndent1" href="#LIX-B">IX-B. pthread_cond_signal</a>
			



			
		

		<br><a class="summaryIndent1" href="#LIX-C">IX-C. pthread_cond_broadcast</a>
			



			
		
	

	<br><a class="summaryIndent0" href="#LX">X. Mise en pratique</a>
		

		

		<br><a class="summaryIndent1" href="#LX-A">X-A. Fonction : fn_store</a>
			



			
		

		<br><a class="summaryIndent1" href="#LX-B">X-B. Fonction : fn_clients</a>
			



			
		

		<br><a class="summaryIndent1" href="#LX-C">X-C. Code complet</a>
			

			



			
		

		<br><a class="summaryIndent1" href="#LX-D">X-D. Sortie du programme</a>
			

			



			

			
		

		<br><a class="summaryIndent1" href="#LX-E">X-E. Observations</a>
			

			
		
	

	<br><a class="summaryIndent0" href="#LXI">XI. Test des threads</a>
		

		

		<br><a class="summaryIndent1" href="#LXI-A">XI-A. pthread_equal</a>
			



			
		

		<br><a class="summaryIndent1" href="#LXI-B">XI-B. pthread_self</a>
			



			
		
	

	<br><a class="summaryIndent0" href="#LXII">XII. Conclusion</a>
		

		
	

	<br><a class="summaryIndent0" href="#LXIII">XIII. Remerciements</a>
		

		
	
<br><br>
	<br><h1 class="TitreSection0" id="LI">I. Introduction</h1>
		

		<div class="paragraph">
			La programmation multitâche a toujours été et est toujours, un sujet assez complexe, 
			essentiellement dû au manque de documentation et tutoriels en français !
			<br>
			<br>
			Ce tutoriel ne se veut pas une documentation complète <i>(il existe des ouvrages dédiés 
			sur ce sujet)</i> mais plutôt une initiation pour vous donner un aperçu de ce qu'il est possible de faire 
			et nous ferons un petit tour d'horizon de la bibliothèque <b>pthread</b> au fil de l'eau.
 			<br>
			<br>
			Nous nous baserons sur un sujet d'exemple unique soit, une gestion correcte d'un stock de magasin 
			et des clients. Le but bien entendu, est que le stock ne descende jamais en-dessous de zéro, ce qui 
			dans la réalité n'est pas faisable donc, si le stock descend à zéro ou si le client courant demande plus 
			de produit qu'il y en a en stock, il faut renflouer celui-ci. Chaque client est représenté par un thread, 
			dans notre exemple nous allons en créer <b>5</b>, la gestion du stock est également un thread 
			supplémentaire.
		</div><br>
	

	<br><h1 class="TitreSection0" id="LII">II. Avant de commencer</h1>
		

		<div class="paragraph">
			La bibliothèque Pthreads est portable, elle existe sur Linux ainsi que sur Windows. Si vous êtes sur Windows, 
			il vous faudra cependant l'installer car elle ne l'est pas d'office sur ce système ! Vous pouvez télécharger la 
			bibliothèque sur le site suivant: <img src="pthread_init_files/kiten.jpg" alt="en">&nbsp;<a href="http://sourceware.org/pthreads-win32/" class="lienArticle">http://sourceware.org/pthreads-win32/</a>.
			<br>
			<br>
			Pour pouvoir compiler un projet <i>(tous systèmes)</i> avec pthread, il faut pour commencer, ajouter 
			l'en-tête :
		</div>

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e138"><tbody><tr><td class="code"><div id="codeWrapperd0e138" class="codeWrapper"><div id="codeOverflowd0e138" style="overflow: auto;"><pre><code id="contenuCoded0e138" class="contenuCode"><code class="c_keyword2">#</code><code class="c_markup">include</code><code class="c_keyword2"> </code><code class="c_keyword2">&lt;pthread.h&gt;</code>
</code></pre></div></div></td></tr></tbody></table></div>

		<div class="paragraph">
			ainsi qu'ajouter à l'éditeur de lien la bibliothèque :
		</div>

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e152"><tbody><tr><td class="code"><div id="codeWrapperd0e152" class="codeWrapper"><div id="codeOverflowd0e152" style="overflow: auto;"><pre><code id="contenuCoded0e152" class="contenuCode">-lpthread
</code></pre></div></div></td></tr></tbody></table></div>

		<div class="paragraph">
			et spécifier au compilateur la constante :
		</div>

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e158"><tbody><tr><td class="code"><div id="codeWrapperd0e158" class="codeWrapper"><div id="codeOverflowd0e158" style="overflow: auto;"><pre><code id="contenuCoded0e158" class="contenuCode">-D_REENTRANT
</code></pre></div></div></td></tr></tbody></table></div>

		<div class="paragraph">
			Vous voilà prêt pour compiler des programmes utilisant la bibliothèque Pthreads !
		</div><br>

		<table class="infobulle" style="border: 0pt none ; width: 98%; text-align: left;"><tbody><tr><td style="width: 40px; vertical-align: top;" class="colonne"><img src="pthread_init_files/kitwarning.gif" alt="warning"></td><td class="colonne">
			Attention, avec le compilateur MingW sous Windows, si vous développez une application C++ 
			utilisant des exceptions, il est nécessaire de compiler et de réaliser l'édition des liens avec l'option <b>-mthreads</b>. 
			En effet, d'origine, les exceptions ne sont pas thread-safe, l'option <i>mthreads</i> permet qu'elles le soient.
		<br></td></tr></tbody></table>

		<table class="infobulle" style="border: 0pt none ; width: 98%; text-align: left;"><tbody><tr><td style="width: 40px; vertical-align: top;" class="colonne"><img src="pthread_init_files/kitinfo.gif" alt="info"></td><td class="colonne">
			Les utilisateurs de Linux devront spécifier dans la ligne de compilation des exemples de ce tutoriel, 
			la constante <b>-DLinux</b> et les utilisateurs de Windows <b>-DWin32</b>. Cela sert à prendre 
			en charge de façon portable la mise en pause des portions du code d'exemple. Un fichier Makefile 
			est également disponible pour les utilisateurs de Linux !
		<br></td></tr></tbody></table>
	

	<br><h1 class="TitreSection0" id="LIII">III. Qu'est-ce qu'un thread ?</h1>
		

		<div class="paragraph">
			Un <b>thread</b> <i>(Fil ou encore Fil d'exécution)</i> est une portion de code <i>(fonction)</i> qui se déroule en parallèle au thread 
			principal (aussi appelé <i>main</i>). Ce principe est un peu semblable à la fonction 
			<a href="http://man.developpez.com/man2/fork.2.php" class="lienArticle">fork</a>
sur Linux par exemple sauf que nous ne faisons pas de copie du
processus père, nous définissons des fonctions qui vont se lancer en
même temps que le processus, ce qui permet de faire de la programmation
multitâche. Le but est donc de permettre au programme de réaliser
plusieurs actions au même moment (imaginez un programme qui fait un
gros calcul et une barre de progression qui avance en même temps). <br><br>
			On peut également considérer un thread comme un processus allégé pour mieux imager le tout ! En comparaison des threads, 
			un fork prend en moyenne 30 fois plus de temps à faire !
		</div><br>
	

	<br><h1 class="TitreSection0" id="LIV">IV. Création et exécution des threads</h1>
		

		<br><h2 class="TitreSection1" id="LIV-A">IV-A. pthread_create</h2>
			
	
			<div class="paragraph">
				Un thread se créé avec la fonction :
			</div>

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e223"><tbody><tr><td class="code"><div id="codeWrapperd0e223" class="codeWrapper"><div id="codeOverflowd0e223" style="overflow: auto;"><pre><code id="contenuCoded0e223" class="contenuCode"><code class="c_keyword3">int</code> pthread_create (pthread_t <code class="c_operator">*</code> thread, pthread_attr_t <code class="c_operator">*</code> attr, <code class="c_keyword3">void</code> <code class="c_operator">*</code> (<code class="c_operator">*</code> start_routine) (<code class="c_keyword3">void</code> <code class="c_operator">*</code>), <code class="c_keyword3">void</code> <code class="c_operator">*</code> arg); 
</code></pre></div></div></td></tr></tbody></table></div>

			<div class="paragraph">
				Voyons dans l'ordre, à quoi correspondent ses arguments :
			</div><br>

			<ol style="list-style-type: decimal;">
				<li>
					Le type <b>pthread_t</b> est un type opaque, sa valeur réelle dépend de l'implémentation <i>(sur Linux il s'agit en
					générale du type <b>unsigned long</b>)</i>. Ce type correspond à l'identifiant du thread qui sera créé, tout comme 
					les processus on leur propre identifiant.
				</li>
				<li>
					Le type <b>pthread_attr_t</b> est un autre type opaque permettant de définir des attributs spécifiques pour chaque 
					thread mais cela dépasse le cadre de ce tutoriel. Il faut simplement savoir que l'on peut changer le comportement de 
					la gestion des threads comme par exemple, les régler pour qu'ils tournent sur un <i>système temps réel</i> ! 
					En générale on se contente des attributs par défaut donc en mettant cet argument à NULL.
				</li>
				<li>
					Chaque thread dispose d'une fonction à exécuter, c'est en même temps sa raison de vivre... Cet argument permet 
					de transmettre un pointeur sur la fonction qu'il devra exécuter.
				</li>
				<li>
					Ce dernier argument représente un argument que l'on peut passer à la fonction que le thread doit exécuter.
				</li>
			</ol>
	
			<div class="paragraph">
				Si la création réussit, la fonction renvoie <b>0</b> <i>(zéro)</i> et l'identifiant du thread nouvellement créé est 
				stocké à l'adresse fournie en premier argument. En cas d'erreur, la valeur <b>EAGAIN</b> est retournée par la fonction 
				s'il n'y a pas assez de ressources système pour créer un nouveau thread ou bien si le nombre maximum de threads définit 
				par la constante <b>PTHREAD_THREADS_MAX</b> est atteint !
			</div><br>

			<table class="infobulle" style="border: 0pt none ; width: 98%; text-align: left;"><tbody><tr><td style="width: 40px; vertical-align: top;" class="colonne"><img src="pthread_init_files/kitwarning.gif" alt="warning"></td><td class="colonne">
				Le nombre de threads simultanés est limité suivant les systèmes. La constante <b>PTHREAD_THREADS_MAX</b> définie 
				le nombre maximum qui est de <b>1024</b> sur les Unixoïdes !
			<br></td></tr></tbody></table>

			<div class="paragraph">
Lorsque le thread est créé, il est lancé immédiatement et exécute la
fonction passée en troisième argument. L'exécution du thread se fait
soit jusqu'à la fin de sa fonction ou bien jusqu'à son annulation,
c'est ce que nous allons voir au prochain chapitre. </div><br>

			<table class="infobulle" style="border: 0pt none ; width: 98%; text-align: left;"><tbody><tr><td style="width: 40px; vertical-align: top;" class="colonne"><img src="pthread_init_files/kitidea.gif" alt="idea"></td><td class="colonne">
				Il est possible d'attribuer la même fonction à plusieurs threads !
			<br></td></tr></tbody></table>
		
	

	<br><h1 class="TitreSection0" id="LV">V. Annulation et fin des threads</h1>
		

		<br><h2 class="TitreSection1" id="LV-A">V-A. pthread_exit</h2>
			

			<div class="paragraph">
				On peut arrêter le thread courant avec la fonction :
			</div>

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e333"><tbody><tr><td class="code"><div id="codeWrapperd0e333" class="codeWrapper"><div id="codeOverflowd0e333" style="overflow: auto;"><pre><code id="contenuCoded0e333" class="contenuCode"><code class="c_keyword3">void</code> pthread_exit (<code class="c_keyword3">void</code> <code class="c_operator">*</code> retval);
</code></pre></div></div></td></tr></tbody></table></div>

			<div class="paragraph">
				Son seul argument est le retour de la fonction du thread appelant. Cet argument peut aussi être récupéré par 
				la fonction <b>pthread_join</b> que nous verrons plus bas.
			</div><br>
		

		<br><h2 class="TitreSection1" id="LV-B">V-B. pthread_cancel</h2>
			

			<div class="paragraph">
				On peut annuler un thread à partir d'un autre à n'importe quel moment avec la fonction :
			</div>

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e359"><tbody><tr><td class="code"><div id="codeWrapperd0e359" class="codeWrapper"><div id="codeOverflowd0e359" style="overflow: auto;"><pre><code id="contenuCoded0e359" class="contenuCode"><code class="c_keyword3">int</code> pthread_cancel (pthread_t thread);
</code></pre></div></div></td></tr></tbody></table></div>

			<div class="paragraph">
				L'argument de cette fonction est le thread à annuler. Elle renvoie <b>0</b> <i>(zéro)</i> si elle réussie ou 
				la valeur <b>ESRCH</b> si aucun thread ne correspond à celui passé en argument.
			</div><br>

			<div class="paragraph">
				Il faut cependant être très vigilant lors de l'utilisation de cette fonction. En effet, si le thread dont on demande 
				l'arrêt possède un verrou et ne l'a toujours pas relâché, il y a un risque de laisser ce verrou dans l'état <i>verrouillé</i>, 
				il sera alors dans ce cas impossible de le récupérer !
				<br><br>
				Pour éviter ce genre de phénomène, on peut avoir recours à une fonction permettant de changer 
				le comportement du thread par rapport aux requêtes d'annulations, ce que nous allons voir ci-dessous ! 
			</div><br>

			<br><h3 class="TitreSection2" id="LV-B-1">V-B-1. pthread_setcancelstate</h3>
				
				
<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e390"><tbody><tr><td class="code"><div id="codeWrapperd0e390" class="codeWrapper"><div id="codeOverflowd0e390" style="overflow: auto;"><pre><code id="contenuCoded0e390" class="contenuCode"><code class="c_keyword3">int</code> pthread_setcancelstate (<code class="c_keyword3">int</code> state, <code class="c_keyword3">int</code> <code class="c_operator">*</code> etat_pred);
</code></pre></div></div></td></tr></tbody></table></div>

				<div class="paragraph">
					Cette fonction permet de changer le comportement du thread appelant par rapport aux requêtes d'annulations. 
					Ces arguments sont dans l'ordre:
				</div><br>

				<ul style="list-style-type: disc;">
					<li>
						Etat d'annulation. Il peut prendre les deux valeurs suivantes :
					</li>
						<ul style="list-style-type: disc;">
							<li>
								<b>PTHREAD_CANCEL_ENABLE</b> : Autorise les annulations pour le thread appelant.
							</li>
							<li>
								<b>PTHREAD_CANCEL_DISABLE</b> : Désactive les requêtes d'annulation.
							</li>
						</ul>
					<li>
						Adresse vers l'état précédent <i>(ou NULL)</i> permettant ainsi sa restauration lors d'un prochain appel 
						de la fonction.
					</li>
				</ul>

				<div class="paragraph">
					La fonction renvoie la valeur <b>0</b> en cas de succès ou <b>EINVAL</b> si l'argument ne correspond 
					ni à <i>PTHREAD_CANCEL_ENABLE</i> et ni à <i>PTHREAD_CANCEL_DISABLE</i> !
				</div><br>
			
		

		<br><h2 class="TitreSection1" id="LV-C">V-C. pthread_join</h2>
			

			<div class="paragraph">
				Lorsque nous créons des threads puis nous laissons continuer par exemple la fonction <i>main</i>, nous prenons 
				le risque de terminer le programme complètement sans avoir pu exécuter les threads. Nous devons en effet attendre 
				que les différents threads créés se terminent. Pour cela, il existe la fonction :
			</div>

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e462"><tbody><tr><td class="code"><div id="codeWrapperd0e462" class="codeWrapper"><div id="codeOverflowd0e462" style="overflow: auto;"><pre><code id="contenuCoded0e462" class="contenuCode"><code class="c_keyword3">int</code> pthread_join (pthread_t th, <code class="c_keyword3">void</code> <code class="c_operator">*</code><code class="c_operator">*</code> thread_return);
</code></pre></div></div></td></tr></tbody></table></div>

			<div class="paragraph">
				Ses arguments sont dans l'ordre :
			</div><br>

			<ol style="list-style-type: decimal;">
				<li>
					Le thread à attendre.
				</li>
				<li>
					La valeur de retour de la fonction du thread <b>th</b>.
				</li>
			</ol>

			<div class="paragraph">
				L'appel de cette fonction met en pause l'exécution du thread appelant jusqu'au retour de la fonction. Si aucun problème 
				n'a eu lieu, elle retourne <b>0</b> <i>(zéro)</i> et la valeur de retour du thread est passé à l'adresse indiquée 
				(second argument) si elle est différente de NULL. En cas de problème, la fonction retourne une des valeurs suivantes :
			</div><br>

			<ul style="list-style-type: disc;">
				<li><b>ESRCH</b> : Aucun thread ne correspond à celui passé en argument.</li>
				<li><b>EINVAL</b> : Le thread a été détaché ou un autre thread attend déjà la fin du même thread.</li>
				<li><b>EDEADLK</b> : Le thread passé en argument correspond au thread appelant.</li>
			</ul>

			<table class="infobulle" style="border: 0pt none ; width: 98%; text-align: left;"><tbody><tr><td style="width: 40px; vertical-align: top;" class="colonne"><img src="pthread_init_files/kitinfo.gif" alt="info"></td><td class="colonne">
Un thread terminé ne peut être relancé, il faut en créer un nouveau car
un thread qui touche à sa fin est implicitement détruit ! <br></td></tr></tbody></table>
		
	

	<br><h1 class="TitreSection0" id="LVI">VI. Mise en pratique</h1>
		

		<div class="paragraph">
			Dans ce programme, nous créons <b>1</b> thread pour la gestion du stock du magasin et <b>5</b> threads pour 
			les clients. Les deux fonctions <b>fn_store</b> et <b>fn_clients</b> sont des boucles infinies <i>(pour cet exemple mais 
			dans la réalité ca ne sera pas toujours le cas)</i>
exécutant les mêmes tâches. Les threads clients prennent dans le stock
et le thread du magasin va renflouer le stock dès qu'il devient trop
bas pour satisfaire les clients. Le nombre d'articles pris du stock
sont des nombres aléatoires ainsi que l'ordre de passage des clients. <br><br>
			Nous pouvons voir qu'à la fin de la fonction <i>main</i>, nous avons une boucle qui parcourt chaque threads en lançant la fonction 
			<i>pthread_join</i>. Ceci permet d'attendre la fin des threads et évite donc que le programme ne se termine et quitte 
			prématurément les threads !
		</div><br>

		<br><h2 class="TitreSection1" id="LVI-A">VI-A. Code complet</h2>
			

			<div class="paragraph">
				Exemple numéro 1. Vous pouvez télécharger l'archive <a href="http://franckh.developpez.com/tutoriels/posix/pthreads/sources/pthread-exemple-1.zip" class="lienArticle">ici</a> !
			</div>

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e565"><tbody><tr><td class="code"><div id="codeWrapperd0e565" class="codeWrapper"><div id="codeOverflowd0e565" style="overflow: auto;"><pre><code id="contenuCoded0e565" class="contenuCode"><code class="c_keyword2">#</code><code class="c_markup">include</code><code class="c_keyword2"> </code><code class="c_keyword2">&lt;stdio.h&gt;</code>
<code class="c_keyword2">#</code><code class="c_markup">include</code><code class="c_keyword2"> </code><code class="c_keyword2">&lt;stdlib.h&gt;</code>
<code class="c_keyword2">#</code><code class="c_markup">include</code><code class="c_keyword2"> </code><code class="c_keyword2">&lt;pthread.h&gt;</code>

<code class="c_keyword2">#</code><code class="c_markup">if</code><code class="c_keyword2"> </code><code class="c_keyword2">defined</code><code class="c_keyword2"> </code><code class="c_keyword2">(</code><code class="c_keyword2">Win32</code><code class="c_keyword2">)</code>
<code class="c_keyword2">#</code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_markup">include</code><code class="c_keyword2"> </code><code class="c_keyword2">&lt;windows.h&gt;</code>
<code class="c_keyword2">#</code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_markup">define</code><code class="c_keyword2"> </code><code class="c_keyword2">psleep</code><code class="c_keyword2">(</code><code class="c_keyword2">sec</code><code class="c_keyword2">)</code><code class="c_keyword2"> </code><code class="c_keyword2">Sleep</code><code class="c_keyword2"> </code><code class="c_keyword2">(</code><code class="c_keyword2">(</code><code class="c_keyword2">sec</code><code class="c_keyword2">)</code><code class="c_keyword2"> </code><code class="c_keyword2">*</code><code class="c_keyword2"> </code><code class="c_digit">1000</code><code class="c_keyword2">)</code>
<code class="c_keyword2">#</code><code class="c_markup">elif</code><code class="c_keyword2"> </code><code class="c_keyword2">defined</code><code class="c_keyword2"> </code><code class="c_keyword2">(</code><code class="c_keyword2">Linux</code><code class="c_keyword2">)</code>
<code class="c_keyword2">#</code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_markup">include</code><code class="c_keyword2"> </code><code class="c_keyword2">&lt;unistd.h&gt;</code>
<code class="c_keyword2">#</code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_markup">define</code><code class="c_keyword2"> </code><code class="c_keyword2">psleep</code><code class="c_keyword2">(</code><code class="c_keyword2">sec</code><code class="c_keyword2">)</code><code class="c_keyword2"> </code><code class="c_keyword2">sleep</code><code class="c_keyword2"> </code><code class="c_keyword2">(</code><code class="c_keyword2">(</code><code class="c_keyword2">sec</code><code class="c_keyword2">)</code><code class="c_keyword2">)</code>
<code class="c_keyword2">#</code><code class="c_markup">endif</code>

<code class="c_keyword2">#</code><code class="c_markup">define</code><code class="c_keyword2"> </code><code class="c_keyword2">INITIAL_STOCK</code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_digit">20</code>
<code class="c_keyword2">#</code><code class="c_markup">define</code><code class="c_keyword2"> </code><code class="c_keyword2">NB_CLIENTS</code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_digit">5</code>


<code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Structure</code><code class="c_comment1"> </code><code class="c_comment1">stockant</code><code class="c_comment1"> </code><code class="c_comment1">les</code><code class="c_comment1"> </code><code class="c_comment1">informations</code><code class="c_comment1"> </code><code class="c_comment1">des</code><code class="c_comment1"> </code><code class="c_comment1">threads</code><code class="c_comment1"> </code><code class="c_comment1">clients</code><code class="c_comment1"> </code><code class="c_comment1">et</code><code class="c_comment1"> </code><code class="c_comment1">du</code><code class="c_comment1"> </code><code class="c_comment1">magasin.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
<code class="c_keyword3">typedef</code> <code class="c_keyword3">struct</code>
<code class="c_operator">{</code>
   <code class="c_keyword3">int</code> stock;

   pthread_t thread_store;
   pthread_t thread_clients [NB_CLIENTS];
<code class="c_operator">}</code>
store_t;

<code class="c_keyword1">static</code> store_t store <code class="c_operator">=</code>
<code class="c_operator">{</code>
   .stock <code class="c_operator">=</code> INITIAL_STOCK,
<code class="c_operator">}</code>;


<code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Fonction</code><code class="c_comment1"> </code><code class="c_comment1">pour</code><code class="c_comment1"> </code><code class="c_comment1">tirer</code><code class="c_comment1"> </code><code class="c_comment1">un</code><code class="c_comment1"> </code><code class="c_comment1">nombre</code><code class="c_comment1"> </code><code class="c_comment1">au</code><code class="c_comment1"> </code><code class="c_comment1">sort</code><code class="c_comment1"> </code><code class="c_comment1">entre</code><code class="c_comment1"> </code><code class="c_comment1">0</code><code class="c_comment1"> </code><code class="c_comment1">et</code><code class="c_comment1"> </code><code class="c_comment1">max.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
<code class="c_keyword1">static</code> <code class="c_keyword3">int</code> get_random (<code class="c_keyword3">int</code> max)
<code class="c_operator">{</code>
   <code class="c_keyword3">double</code> val;

   val <code class="c_operator">=</code> (<code class="c_keyword3">double</code>) max <code class="c_operator">*</code> rand ();
   val <code class="c_operator">=</code> val <code class="c_operator">/</code> (RAND_MAX <code class="c_operator">+</code> <code class="c_digit">1</code>.<code class="c_digit">0</code>);

   <code class="c_keyword1">return</code> ((<code class="c_keyword3">int</code>) val);
<code class="c_operator">}</code>


<code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Fonction</code><code class="c_comment1"> </code><code class="c_comment1">pour</code><code class="c_comment1"> </code><code class="c_comment1">le</code><code class="c_comment1"> </code><code class="c_comment1">thread</code><code class="c_comment1"> </code><code class="c_comment1">du</code><code class="c_comment1"> </code><code class="c_comment1">magasin.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
<code class="c_keyword1">static</code> <code class="c_keyword3">void</code> <code class="c_operator">*</code> fn_store (<code class="c_keyword3">void</code> <code class="c_operator">*</code> p_data)
<code class="c_operator">{</code>
   <code class="c_keyword1">while</code> (<code class="c_digit">1</code>)
   <code class="c_operator">{</code>
      <code class="c_keyword1">if</code> (store.stock <code class="c_operator">&lt;=</code> <code class="c_digit">0</code>)
      <code class="c_operator">{</code>
         store.stock <code class="c_operator">=</code> INITIAL_STOCK;
         printf (<code class="c_literal1">"</code><code class="c_literal1">Remplissage</code><code class="c_literal1"> </code><code class="c_literal1">du</code><code class="c_literal1"> </code><code class="c_literal1">stock</code><code class="c_literal1"> </code><code class="c_literal1">de</code><code class="c_literal1"> </code><code class="c_literal1">%d</code><code class="c_literal1"> </code><code class="c_literal1">articles</code><code class="c_literal1"> </code><code class="c_literal1">!\n</code><code class="c_literal1">"</code>, store.stock);
      <code class="c_operator">}</code>
   <code class="c_operator">}</code>

   <code class="c_keyword1">return</code> <code class="c_literal2">NULL</code>;
<code class="c_operator">}</code>


<code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Fonction</code><code class="c_comment1"> </code><code class="c_comment1">pour</code><code class="c_comment1"> </code><code class="c_comment1">les</code><code class="c_comment1"> </code><code class="c_comment1">threads</code><code class="c_comment1"> </code><code class="c_comment1">des</code><code class="c_comment1"> </code><code class="c_comment1">clients.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
<code class="c_keyword1">static</code> <code class="c_keyword3">void</code> <code class="c_operator">*</code> fn_clients (<code class="c_keyword3">void</code> <code class="c_operator">*</code> p_data)
<code class="c_operator">{</code>
   <code class="c_keyword3">int</code> nb <code class="c_operator">=</code> (<code class="c_keyword3">int</code>) p_data;

   <code class="c_keyword1">while</code> (<code class="c_digit">1</code>)
   <code class="c_operator">{</code>
      <code class="c_keyword3">int</code> val <code class="c_operator">=</code> get_random (<code class="c_digit">6</code>);

      psleep (get_random (<code class="c_digit">3</code>));

      store.stock <code class="c_operator">=</code> store.stock <code class="c_operator">-</code> val;
      printf (
         <code class="c_literal1">"</code><code class="c_literal1">Client</code><code class="c_literal1"> </code><code class="c_literal1">%d</code><code class="c_literal1"> </code><code class="c_literal1">prend</code><code class="c_literal1"> </code><code class="c_literal1">%d</code><code class="c_literal1"> </code><code class="c_literal1">du</code><code class="c_literal1"> </code><code class="c_literal1">stock,</code><code class="c_literal1"> </code><code class="c_literal1">reste</code><code class="c_literal1"> </code><code class="c_literal1">%d</code><code class="c_literal1"> </code><code class="c_literal1">en</code><code class="c_literal1"> </code><code class="c_literal1">stock</code><code class="c_literal1"> </code><code class="c_literal1">!\n</code><code class="c_literal1">"</code>,
         nb, val, store.stock
      );
   <code class="c_operator">}</code>

   <code class="c_keyword1">return</code> <code class="c_literal2">NULL</code>;
<code class="c_operator">}</code>


<code class="c_keyword3">int</code> main (<code class="c_keyword3">void</code>)
<code class="c_operator">{</code>
   <code class="c_keyword3">int</code> i <code class="c_operator">=</code> <code class="c_digit">0</code>;
   <code class="c_keyword3">int</code> ret <code class="c_operator">=</code> <code class="c_digit">0</code>;


   <code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Creation</code><code class="c_comment1"> </code><code class="c_comment1">du</code><code class="c_comment1"> </code><code class="c_comment1">thread</code><code class="c_comment1"> </code><code class="c_comment1">du</code><code class="c_comment1"> </code><code class="c_comment1">magasin.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
   printf (<code class="c_literal1">"</code><code class="c_literal1">Creation</code><code class="c_literal1"> </code><code class="c_literal1">du</code><code class="c_literal1"> </code><code class="c_literal1">thread</code><code class="c_literal1"> </code><code class="c_literal1">du</code><code class="c_literal1"> </code><code class="c_literal1">magasin</code><code class="c_literal1"> </code><code class="c_literal1">!\n</code><code class="c_literal1">"</code>);
   ret <code class="c_operator">=</code> pthread_create (
      <code class="c_operator">&amp;</code> store.thread_store, <code class="c_literal2">NULL</code>,
      fn_store, <code class="c_literal2">NULL</code>
   );

   <code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Creation</code><code class="c_comment1"> </code><code class="c_comment1">des</code><code class="c_comment1"> </code><code class="c_comment1">threads</code><code class="c_comment1"> </code><code class="c_comment1">des</code><code class="c_comment1"> </code><code class="c_comment1">clients</code><code class="c_comment1"> </code><code class="c_comment1">si</code><code class="c_comment1"> </code><code class="c_comment1">celui</code><code class="c_comment1"> </code><code class="c_comment1">du</code><code class="c_comment1"> </code><code class="c_comment1">magasin</code><code class="c_comment1"> </code><code class="c_comment1">a</code><code class="c_comment1"> </code><code class="c_comment1">reussi.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
   <code class="c_keyword1">if</code> (<code class="c_operator">!</code> ret)
   <code class="c_operator">{</code>
      printf (<code class="c_literal1">"</code><code class="c_literal1">Creation</code><code class="c_literal1"> </code><code class="c_literal1">des</code><code class="c_literal1"> </code><code class="c_literal1">threads</code><code class="c_literal1"> </code><code class="c_literal1">clients</code><code class="c_literal1"> </code><code class="c_literal1">!\n</code><code class="c_literal1">"</code>);
      <code class="c_keyword1">for</code> (i <code class="c_operator">=</code> <code class="c_digit">0</code>; i <code class="c_operator">&lt;</code> NB_CLIENTS; i<code class="c_operator">+</code><code class="c_operator">+</code>)
      <code class="c_operator">{</code>
         ret <code class="c_operator">=</code> pthread_create (
            <code class="c_operator">&amp;</code> store.thread_clients [i], <code class="c_literal2">NULL</code>,
            fn_clients, (<code class="c_keyword3">void</code> <code class="c_operator">*</code>) i
         );

         <code class="c_keyword1">if</code> (ret)
         <code class="c_operator">{</code>
            fprintf (stderr, <code class="c_literal1">"</code><code class="c_literal1">%s</code><code class="c_literal1">"</code>, strerror (ret));
         <code class="c_operator">}</code>
      <code class="c_operator">}</code>
   <code class="c_operator">}</code>
   <code class="c_keyword1">else</code>
   <code class="c_operator">{</code>
      fprintf (stderr, <code class="c_literal1">"</code><code class="c_literal1">%s</code><code class="c_literal1">"</code>, strerror (ret));
   <code class="c_operator">}</code>

   
   <code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Attente</code><code class="c_comment1"> </code><code class="c_comment1">de</code><code class="c_comment1"> </code><code class="c_comment1">la</code><code class="c_comment1"> </code><code class="c_comment1">fin</code><code class="c_comment1"> </code><code class="c_comment1">des</code><code class="c_comment1"> </code><code class="c_comment1">threads.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
   i <code class="c_operator">=</code> <code class="c_digit">0</code>;
   <code class="c_keyword1">for</code> (i <code class="c_operator">=</code> <code class="c_digit">0</code>; i <code class="c_operator">&lt;</code> NB_CLIENTS; i<code class="c_operator">+</code><code class="c_operator">+</code>)
   <code class="c_operator">{</code>
      pthread_join (store.thread_clients [i], <code class="c_literal2">NULL</code>);
   <code class="c_operator">}</code>
   pthread_join (store.thread_store, <code class="c_literal2">NULL</code>);


   <code class="c_keyword1">return</code> EXIT_SUCCESS;
<code class="c_operator">}</code>
</code></pre></div></div></td></tr></tbody></table></div>

			<table class="infobulle" style="border: 0pt none ; width: 98%; text-align: left;"><tbody><tr><td style="width: 40px; vertical-align: top;" class="colonne"><img src="pthread_init_files/kitwarning.gif" alt="warning"></td><td class="colonne">
				L'exemple de code ci-dessus utilise une variable globale ! Ici ce n'est qu'à titre d'exemple mais je 
				vous encourage à éviter ce genre de pratique autant que possible !
			<br></td></tr></tbody></table>
		

		<br><h2 class="TitreSection1" id="LVI-B">VI-B. Sortie du programme</h2>
			

			<div class="paragraph">
				Voici la sortie du programme sur la console avec annulation utilisateur :
			</div>

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e1549"><tbody><tr><td class="code"><div id="codeWrapperd0e1549" class="codeWrapper"><div id="codeOverflowd0e1549" style="overflow: auto;"><pre><code id="contenuCoded0e1549" class="contenuCode">Creation du thread du magasin !
Creation des threads clients !
Client 2 prend 5 du stock, reste 15 en stock !
Client 0 prend 5 du stock, reste 10 en stock !
Client 3 prend 1 du stock, reste 9 en stock !
Client 4 prend 2 du stock, reste 7 en stock !
Client 1 prend 4 du stock, reste 3 en stock !
Client 2 prend 2 du stock, reste 1 en stock !
Client 2 prend 0 du stock, reste 1 en stock !
Client 0 prend 2 du stock, reste -1 en stock !
Remplissage du stock de 20 articles !
Client 1 prend 0 du stock, reste 20 en stock !
Client 1 prend 0 du stock, reste 20 en stock !
Client 1 prend 5 du stock, reste 15 en stock !
Client 0 prend 0 du stock, reste 15 en stock !
Client 0 prend 3 du stock, reste 12 en stock !
Client 3 prend 5 du stock, reste 7 en stock !
Client 4 prend 3 du stock, reste 4 en stock !
Client 2 prend 0 du stock, reste 4 en stock !
Client 0 prend 3 du stock, reste 1 en stock !
Client 1 prend 3 du stock, reste -2 en stock !
Client 3 prend 2 du stock, reste -4 en stock !
Client 4 prend 1 du stock, reste -5 en stock !
Remplissage du stock de 20 articles !
Client 2 prend 3 du stock, reste 17 en stock !
Client 2 prend 3 du stock, reste 14 en stock !
Client 1 prend 1 du stock, reste 13 en stock !
Client 0 prend 2 du stock, reste 11 en stock !
Client 0 prend 0 du stock, reste 11 en stock !
Client 0 prend 2 du stock, reste 9 en stock !

&lt;CTRL-C&gt;
</code></pre></div></div></td></tr></tbody></table></div>

			<div class="paragraph">
				Et la charge CPU utilisée durant le déroulement du processus et ses threads :
			</div><br>

			<div class="image" style="text-align: center;"><img src="pthread_init_files/cpu-exemple-1.png" alt=""><div style="text-align: center;" class="legimage">Charge CPU de l'exemple 1</div></div>
		

		<br><h2 class="TitreSection1" id="LVI-C">VI-C. Observations</h2>
			

			<div class="paragraph">
				Nous pouvons voir grâce à ces données crées lors du déroulement du programme que les clients se 
				servent même si plus aucun produit n'est en stock, le stock est donc durant un court moment en 
				négatif, ce qu'il faut éviter dans la réalité !
				<br><br>
				Non seulement les clients se servent au petit bonheur mais en plus, sans prendre en considération que 
				d'autres clients peuvent également prendre dans le même stock et bien sûr, sans prendre en compte 
				que le magasin peut renflouer son stock quand il est au plus bas.
				<br><br>
				Ceci pour noter une chose importante : Les threads ne tiennent en aucun cas compte qu'une autre 
				fonction puisse également accéder à la même variable <i>(accès concurrentiels)</i>, en lecture mais 
				aussi en écriture. Cela peut avoir des répercutions dramatiques dans une application critique !
				<br><br>
				Le prochain chapitre va donc aborder la protection pour les accès concurrentiels autrement dit, les <b><i>mutex</i></b> !
				<br><br>
				En outre, nous pouvons observer la charge CPU utilisée lors du déroulement du programme. On peut noter 
				que les ressources sont utilisées au maximum, ceci surtout dû au fait que la fonction <b>fn_store</b> 
				tourne sans cesse jusqu'à ce qu'on mette fin au programme ! Nous aborderons ce sujet dans la dernière partie 
				de ce tutoriel.
			</div><br>
		
	

	<br><h1 class="TitreSection0" id="LVII">VII. Les mutex</h1>
		

		<div class="paragraph">
			Le<i>(s)</i> <b>mutex</b> <i>(<b>mut</b>ual <b>ex</b>clusion ou zone d'exclusion mutuelle)</i>, est<i>(sont)</i> un système 
			de verrou donnant ainsi une garantie sur la viabilité des données manipulées par les threads. En effet, il arrive même 
			très souvent que plusieurs threads doivent accéder en lecture et/ou en écriture aux mêmes variables. Si un thread 
			possède le verrou, seulement celui-ci peut lire et écrire sur les variables étant dans la 
			portion de code protégée (aussi appelée <i>zone critique</i>). Lorsque le thread a terminé, il libère le verrou et un 
			autre thread peut le prendre à son tour.
			<br><br>
			Pour créer un <i>mutex</i>, il faut tout simplement déclarer une variable du type <b>pthread_mutex_t</b> et 
			l'initialiser avec la constante <b>PTHREAD_MUTEX_INITIALIZER</b> soit par exemple :
		</div>

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e1631"><tbody><tr><td class="code"><div id="codeWrapperd0e1631" class="codeWrapper"><div id="codeOverflowd0e1631" style="overflow: auto;"><pre><code id="contenuCoded0e1631" class="contenuCode"><code class="c_keyword1">static</code> pthread_mutex_t mutex_stock <code class="c_operator">=</code> PTHREAD_MUTEX_INITIALIZER;
</code></pre></div></div></td></tr></tbody></table></div>

		<div class="paragraph">
			Un mutex n'a que deux états possibles, il est soit verrouillé soit déverrouillé. On utilise les deux fonctions ci-dessous 
			pour changer les états.
		</div><br>

		<br><h2 class="TitreSection1" id="LVII-A">VII-A. pthread_mutex_lock</h2>
			

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e1647"><tbody><tr><td class="code"><div id="codeWrapperd0e1647" class="codeWrapper"><div id="codeOverflowd0e1647" style="overflow: auto;"><pre><code id="contenuCoded0e1647" class="contenuCode"><code class="c_keyword3">int</code> pthread_mutex_lock (pthread_mutex_t <code class="c_operator">*</code> mutex);
</code></pre></div></div></td></tr></tbody></table></div>

			<div class="paragraph">
				Cette fonction permet de déterminer le début d'une <i>zone critique</i>. Son seul argument est l'adresse 
				d'un <i>mutex</i> de type <b>pthread_mutex_t</b>. La fonction renvoie <b>0</b> en cas de succès ou 
				l'une des valeurs suivante en cas d'échec:
			</div><br>

			<ul style="list-style-type: disc;">
				<li>
					<b>EINVAL</b> : mutex non initialisé.
				</li>
				<li>
					<b>EDEADLK</b> : mutex déjà verrouillé par un thread différent.
				</li>
			</ul>
		

		<br><h2 class="TitreSection1" id="LVII-B">VII-B. pthread_mutex_unlock</h2>
			

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e1691"><tbody><tr><td class="code"><div id="codeWrapperd0e1691" class="codeWrapper"><div id="codeOverflowd0e1691" style="overflow: auto;"><pre><code id="contenuCoded0e1691" class="contenuCode"><code class="c_keyword3">int</code> pthread_mutex_unlock (pthread_mutex_t <code class="c_operator">*</code> mutex);
</code></pre></div></div></td></tr></tbody></table></div>

			<div class="paragraph">
				Cette fonction permet de relâcher le verrou passé en argument qui est l'adresse 
				d'un <i>mutex</i> de type <b>pthread_mutex_t</b>. La fonction renvoie <b>0</b> en cas de succès ou 
				l'une des valeurs suivante en cas d'échec:
			</div><br>

			<ul style="list-style-type: disc;">
				<li>
					<b>EINVAL</b> : mutex non initialisé.
				</li>
				<li>
					<b>EPERM</b> :  le thread n'a pas la main sur le mutex.
				</li>
			</ul>
		
	

	<br><h1 class="TitreSection0" id="LVIII">VIII. Mise en pratique</h1>
		

		<div class="paragraph">
			Dans la seconde version de notre exemple, des zones critiques ont étés définies dans les fonctions 
			<b>fn_store</b> et <b>fn_clients</b>. On peut remarquer que nous prenons et libérons le mutex à chaque 
			tour de boucle ce qui permet de ne pas bloquer le programme et ainsi, chaque thread aura l'opportunité de 
			le prendre à son tour pour accomplir sa tâche.
		</div><br>

		<table class="infobulle" style="border: 0pt none ; width: 98%; text-align: left;"><tbody><tr><td style="width: 40px; vertical-align: top;" class="colonne"><img src="pthread_init_files/kitwarning.gif" alt="warning"></td><td class="colonne">
			Avant chaque arrêt/annulation/fin d'un thread, il ne faut surtout pas oublier de libérer les verrous car vous 
			risquez le cas échéant, d'obtenir ce qu'on appelle un <i>Dead Lock</i>, le mutex est verrouillé et le restera. 
			Tous les threads voulant l'utiliser vont s'arrêter.
		<br></td></tr></tbody></table>

		<br><h2 class="TitreSection1" id="LVIII-A">VIII-A. Code complet</h2>
			

			<div class="paragraph">
				Exemple numéro 2. Vous pouvez télécharger l'archive <a href="http://franckh.developpez.com/tutoriels/posix/pthreads/sources/pthread-exemple-2.zip" class="lienArticle">ici</a> !
			</div>

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e1759"><tbody><tr><td class="code"><div id="codeWrapperd0e1759" class="codeWrapper"><div id="codeOverflowd0e1759" style="overflow: auto;"><pre><code id="contenuCoded0e1759" class="contenuCode"><code class="c_keyword2">#</code><code class="c_markup">include</code><code class="c_keyword2"> </code><code class="c_keyword2">&lt;stdio.h&gt;</code>
<code class="c_keyword2">#</code><code class="c_markup">include</code><code class="c_keyword2"> </code><code class="c_keyword2">&lt;stdlib.h&gt;</code>
<code class="c_keyword2">#</code><code class="c_markup">include</code><code class="c_keyword2"> </code><code class="c_keyword2">&lt;pthread.h&gt;</code>

<code class="c_keyword2">#</code><code class="c_markup">if</code><code class="c_keyword2"> </code><code class="c_keyword2">defined</code><code class="c_keyword2"> </code><code class="c_keyword2">(</code><code class="c_keyword2">Win32</code><code class="c_keyword2">)</code>
<code class="c_keyword2">#</code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_markup">include</code><code class="c_keyword2"> </code><code class="c_keyword2">&lt;windows.h&gt;</code>
<code class="c_keyword2">#</code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_markup">define</code><code class="c_keyword2"> </code><code class="c_keyword2">psleep</code><code class="c_keyword2">(</code><code class="c_keyword2">sec</code><code class="c_keyword2">)</code><code class="c_keyword2"> </code><code class="c_keyword2">Sleep</code><code class="c_keyword2"> </code><code class="c_keyword2">(</code><code class="c_keyword2">(</code><code class="c_keyword2">sec</code><code class="c_keyword2">)</code><code class="c_keyword2"> </code><code class="c_keyword2">*</code><code class="c_keyword2"> </code><code class="c_digit">1000</code><code class="c_keyword2">)</code>
<code class="c_keyword2">#</code><code class="c_markup">elif</code><code class="c_keyword2"> </code><code class="c_keyword2">defined</code><code class="c_keyword2"> </code><code class="c_keyword2">(</code><code class="c_keyword2">Linux</code><code class="c_keyword2">)</code>
<code class="c_keyword2">#</code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_markup">include</code><code class="c_keyword2"> </code><code class="c_keyword2">&lt;unistd.h&gt;</code>
<code class="c_keyword2">#</code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_markup">define</code><code class="c_keyword2"> </code><code class="c_keyword2">psleep</code><code class="c_keyword2">(</code><code class="c_keyword2">sec</code><code class="c_keyword2">)</code><code class="c_keyword2"> </code><code class="c_keyword2">sleep</code><code class="c_keyword2"> </code><code class="c_keyword2">(</code><code class="c_keyword2">(</code><code class="c_keyword2">sec</code><code class="c_keyword2">)</code><code class="c_keyword2">)</code>
<code class="c_keyword2">#</code><code class="c_markup">endif</code>

<code class="c_keyword2">#</code><code class="c_markup">define</code><code class="c_keyword2"> </code><code class="c_keyword2">INITIAL_STOCK</code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_digit">20</code>
<code class="c_keyword2">#</code><code class="c_markup">define</code><code class="c_keyword2"> </code><code class="c_keyword2">NB_CLIENTS</code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_digit">5</code>


<code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Structure</code><code class="c_comment1"> </code><code class="c_comment1">stockant</code><code class="c_comment1"> </code><code class="c_comment1">les</code><code class="c_comment1"> </code><code class="c_comment1">informations</code><code class="c_comment1"> </code><code class="c_comment1">des</code><code class="c_comment1"> </code><code class="c_comment1">threads</code><code class="c_comment1"> </code><code class="c_comment1">clients</code><code class="c_comment1"> </code><code class="c_comment1">et</code><code class="c_comment1"> </code><code class="c_comment1">du</code><code class="c_comment1"> </code><code class="c_comment1">magasin.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
<code class="c_keyword3">typedef</code> <code class="c_keyword3">struct</code>
<code class="c_operator">{</code>
   <code class="c_keyword3">int</code> stock;

   pthread_t thread_store;
   pthread_t thread_clients [NB_CLIENTS];

   pthread_mutex_t mutex_stock;
<code class="c_operator">}</code>
store_t;

<code class="c_keyword1">static</code> store_t store <code class="c_operator">=</code>
<code class="c_operator">{</code>
   .stock <code class="c_operator">=</code> INITIAL_STOCK,
   .mutex_stock <code class="c_operator">=</code> PTHREAD_MUTEX_INITIALIZER,
<code class="c_operator">}</code>;


<code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Fonction</code><code class="c_comment1"> </code><code class="c_comment1">pour</code><code class="c_comment1"> </code><code class="c_comment1">tirer</code><code class="c_comment1"> </code><code class="c_comment1">un</code><code class="c_comment1"> </code><code class="c_comment1">nombre</code><code class="c_comment1"> </code><code class="c_comment1">au</code><code class="c_comment1"> </code><code class="c_comment1">sort</code><code class="c_comment1"> </code><code class="c_comment1">entre</code><code class="c_comment1"> </code><code class="c_comment1">0</code><code class="c_comment1"> </code><code class="c_comment1">et</code><code class="c_comment1"> </code><code class="c_comment1">max.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
<code class="c_keyword1">static</code> <code class="c_keyword3">int</code> get_random (<code class="c_keyword3">int</code> max)
<code class="c_operator">{</code>
   <code class="c_keyword3">double</code> val;

   val <code class="c_operator">=</code> (<code class="c_keyword3">double</code>) max <code class="c_operator">*</code> rand ();
   val <code class="c_operator">=</code> val <code class="c_operator">/</code> (RAND_MAX <code class="c_operator">+</code> <code class="c_digit">1</code>.<code class="c_digit">0</code>);

   <code class="c_keyword1">return</code> ((<code class="c_keyword3">int</code>) val);
<code class="c_operator">}</code>


<code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Fonction</code><code class="c_comment1"> </code><code class="c_comment1">pour</code><code class="c_comment1"> </code><code class="c_comment1">le</code><code class="c_comment1"> </code><code class="c_comment1">thread</code><code class="c_comment1"> </code><code class="c_comment1">du</code><code class="c_comment1"> </code><code class="c_comment1">magasin.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
<code class="c_keyword1">static</code> <code class="c_keyword3">void</code> <code class="c_operator">*</code> fn_store (<code class="c_keyword3">void</code> <code class="c_operator">*</code> p_data)
<code class="c_operator">{</code>
   <code class="c_keyword1">while</code> (<code class="c_digit">1</code>)
   <code class="c_operator">{</code>
      <code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Debut</code><code class="c_comment1"> </code><code class="c_comment1">de</code><code class="c_comment1"> </code><code class="c_comment1">la</code><code class="c_comment1"> </code><code class="c_comment1">zone</code><code class="c_comment1"> </code><code class="c_comment1">protegee.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
      pthread_mutex_lock (<code class="c_operator">&amp;</code> store.mutex_stock);

      <code class="c_keyword1">if</code> (store.stock <code class="c_operator">&lt;=</code> <code class="c_digit">0</code>)
      <code class="c_operator">{</code>
         store.stock <code class="c_operator">=</code> INITIAL_STOCK;
         printf (<code class="c_literal1">"</code><code class="c_literal1">Remplissage</code><code class="c_literal1"> </code><code class="c_literal1">du</code><code class="c_literal1"> </code><code class="c_literal1">stock</code><code class="c_literal1"> </code><code class="c_literal1">de</code><code class="c_literal1"> </code><code class="c_literal1">%d</code><code class="c_literal1"> </code><code class="c_literal1">articles</code><code class="c_literal1"> </code><code class="c_literal1">!\n</code><code class="c_literal1">"</code>, store.stock);
      <code class="c_operator">}</code>

      <code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Fin</code><code class="c_comment1"> </code><code class="c_comment1">de</code><code class="c_comment1"> </code><code class="c_comment1">la</code><code class="c_comment1"> </code><code class="c_comment1">zone</code><code class="c_comment1"> </code><code class="c_comment1">protegee.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
      pthread_mutex_unlock (<code class="c_operator">&amp;</code> store.mutex_stock);
   <code class="c_operator">}</code>

   <code class="c_keyword1">return</code> <code class="c_literal2">NULL</code>;
<code class="c_operator">}</code>


<code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Fonction</code><code class="c_comment1"> </code><code class="c_comment1">pour</code><code class="c_comment1"> </code><code class="c_comment1">les</code><code class="c_comment1"> </code><code class="c_comment1">threads</code><code class="c_comment1"> </code><code class="c_comment1">des</code><code class="c_comment1"> </code><code class="c_comment1">clients.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
<code class="c_keyword1">static</code> <code class="c_keyword3">void</code> <code class="c_operator">*</code> fn_clients (<code class="c_keyword3">void</code> <code class="c_operator">*</code> p_data)
<code class="c_operator">{</code>
   <code class="c_keyword3">int</code> nb <code class="c_operator">=</code> (<code class="c_keyword3">int</code>) p_data;

   <code class="c_keyword1">while</code> (<code class="c_digit">1</code>)
   <code class="c_operator">{</code>
      <code class="c_keyword3">int</code> val <code class="c_operator">=</code> get_random (<code class="c_digit">6</code>);


      <code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Debut</code><code class="c_comment1"> </code><code class="c_comment1">de</code><code class="c_comment1"> </code><code class="c_comment1">la</code><code class="c_comment1"> </code><code class="c_comment1">zone</code><code class="c_comment1"> </code><code class="c_comment1">protegee.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
      pthread_mutex_lock (<code class="c_operator">&amp;</code> store.mutex_stock);

      psleep (get_random (<code class="c_digit">3</code>));
      
      store.stock <code class="c_operator">=</code> store.stock <code class="c_operator">-</code> val;
      printf (
         <code class="c_literal1">"</code><code class="c_literal1">Client</code><code class="c_literal1"> </code><code class="c_literal1">%d</code><code class="c_literal1"> </code><code class="c_literal1">prend</code><code class="c_literal1"> </code><code class="c_literal1">%d</code><code class="c_literal1"> </code><code class="c_literal1">du</code><code class="c_literal1"> </code><code class="c_literal1">stock,</code><code class="c_literal1"> </code><code class="c_literal1">reste</code><code class="c_literal1"> </code><code class="c_literal1">%d</code><code class="c_literal1"> </code><code class="c_literal1">en</code><code class="c_literal1"> </code><code class="c_literal1">stock</code><code class="c_literal1"> </code><code class="c_literal1">!\n</code><code class="c_literal1">"</code>,
         nb, val, store.stock
      );

      <code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Fin</code><code class="c_comment1"> </code><code class="c_comment1">de</code><code class="c_comment1"> </code><code class="c_comment1">la</code><code class="c_comment1"> </code><code class="c_comment1">zone</code><code class="c_comment1"> </code><code class="c_comment1">protegee.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
      pthread_mutex_unlock (<code class="c_operator">&amp;</code> store.mutex_stock);
   <code class="c_operator">}</code>

   <code class="c_keyword1">return</code> <code class="c_literal2">NULL</code>;
<code class="c_operator">}</code>


<code class="c_keyword3">int</code> main (<code class="c_keyword3">void</code>)
<code class="c_operator">{</code>
   <code class="c_keyword3">int</code> i <code class="c_operator">=</code> <code class="c_digit">0</code>;
   <code class="c_keyword3">int</code> ret <code class="c_operator">=</code> <code class="c_digit">0</code>;


   <code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Creation</code><code class="c_comment1"> </code><code class="c_comment1">du</code><code class="c_comment1"> </code><code class="c_comment1">thread</code><code class="c_comment1"> </code><code class="c_comment1">du</code><code class="c_comment1"> </code><code class="c_comment1">magasin.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
   printf (<code class="c_literal1">"</code><code class="c_literal1">Creation</code><code class="c_literal1"> </code><code class="c_literal1">du</code><code class="c_literal1"> </code><code class="c_literal1">thread</code><code class="c_literal1"> </code><code class="c_literal1">du</code><code class="c_literal1"> </code><code class="c_literal1">magasin</code><code class="c_literal1"> </code><code class="c_literal1">!\n</code><code class="c_literal1">"</code>);
   ret <code class="c_operator">=</code> pthread_create (
      <code class="c_operator">&amp;</code> store.thread_store, <code class="c_literal2">NULL</code>,
      fn_store, <code class="c_literal2">NULL</code>
   );

   <code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Creation</code><code class="c_comment1"> </code><code class="c_comment1">des</code><code class="c_comment1"> </code><code class="c_comment1">threads</code><code class="c_comment1"> </code><code class="c_comment1">des</code><code class="c_comment1"> </code><code class="c_comment1">clients</code><code class="c_comment1"> </code><code class="c_comment1">si</code><code class="c_comment1"> </code><code class="c_comment1">celui</code><code class="c_comment1"> </code><code class="c_comment1">du</code><code class="c_comment1"> </code><code class="c_comment1">magasinn</code><code class="c_comment1"> </code><code class="c_comment1">a</code><code class="c_comment1"> </code><code class="c_comment1">reussi.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
   <code class="c_keyword1">if</code> (<code class="c_operator">!</code> ret)
   <code class="c_operator">{</code>
      printf (<code class="c_literal1">"</code><code class="c_literal1">Creation</code><code class="c_literal1"> </code><code class="c_literal1">des</code><code class="c_literal1"> </code><code class="c_literal1">threads</code><code class="c_literal1"> </code><code class="c_literal1">clients</code><code class="c_literal1"> </code><code class="c_literal1">!\n</code><code class="c_literal1">"</code>);
      <code class="c_keyword1">for</code> (i <code class="c_operator">=</code> <code class="c_digit">0</code>; i <code class="c_operator">&lt;</code> NB_CLIENTS; i<code class="c_operator">+</code><code class="c_operator">+</code>)
      <code class="c_operator">{</code>
         ret <code class="c_operator">=</code> pthread_create (
            <code class="c_operator">&amp;</code> store.thread_clients [i], <code class="c_literal2">NULL</code>,
            fn_clients, (<code class="c_keyword3">void</code> <code class="c_operator">*</code>) i
         );

         <code class="c_keyword1">if</code> (ret)
         <code class="c_operator">{</code>
            fprintf (stderr, <code class="c_literal1">"</code><code class="c_literal1">%s</code><code class="c_literal1">"</code>, strerror (ret));
         <code class="c_operator">}</code>
      <code class="c_operator">}</code>
   <code class="c_operator">}</code>
   <code class="c_keyword1">else</code>
   <code class="c_operator">{</code>
      fprintf (stderr, <code class="c_literal1">"</code><code class="c_literal1">%s</code><code class="c_literal1">"</code>, strerror (ret));
   <code class="c_operator">}</code>

   
   <code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Attente</code><code class="c_comment1"> </code><code class="c_comment1">de</code><code class="c_comment1"> </code><code class="c_comment1">la</code><code class="c_comment1"> </code><code class="c_comment1">fin</code><code class="c_comment1"> </code><code class="c_comment1">des</code><code class="c_comment1"> </code><code class="c_comment1">threads.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
   i <code class="c_operator">=</code> <code class="c_digit">0</code>;
   <code class="c_keyword1">for</code> (i <code class="c_operator">=</code> <code class="c_digit">0</code>; i <code class="c_operator">&lt;</code> NB_CLIENTS; i<code class="c_operator">+</code><code class="c_operator">+</code>)
   <code class="c_operator">{</code>
      pthread_join (store.thread_clients [i], <code class="c_literal2">NULL</code>);
   <code class="c_operator">}</code>
   pthread_join (store.thread_store, <code class="c_literal2">NULL</code>);


   <code class="c_keyword1">return</code> EXIT_SUCCESS;
<code class="c_operator">}</code>
</code></pre></div></div></td></tr></tbody></table></div>

			<table class="infobulle" style="border: 0pt none ; width: 98%; text-align: left;"><tbody><tr><td style="width: 40px; vertical-align: top;" class="colonne"><img src="pthread_init_files/kitwarning.gif" alt="warning"></td><td class="colonne">
				L'exemple de code ci-dessus utilise une variable globale ! Ici ce n'est qu'à titre d'exemple mais je 
				vous encourage à éviter ce genre de pratique autant que possible !
			<br></td></tr></tbody></table>
		

		<br><h2 class="TitreSection1" id="LVIII-B">VIII-B. Sortie du programme</h2>
			

			<div class="paragraph">
				Voici la sortie du programme sur la console avec annulation utilisateur :
			</div>

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e2866"><tbody><tr><td class="code"><div id="codeWrapperd0e2866" class="codeWrapper"><div id="codeOverflowd0e2866" style="overflow: auto;"><pre><code id="contenuCoded0e2866" class="contenuCode">Creation du thread du magasin !
Creation des threads clients !
Client 2 prend 5 du stock, reste 15 en stock !
Client 0 prend 5 du stock, reste 10 en stock !
Client 3 prend 1 du stock, reste 9 en stock !
Client 4 prend 2 du stock, reste 7 en stock !
Client 1 prend 4 du stock, reste 3 en stock !
Client 2 prend 2 du stock, reste 1 en stock !
Client 2 prend 0 du stock, reste 1 en stock !
Client 0 prend 2 du stock, reste -1 en stock !
Remplissage du stock de 20 articles !
Client 1 prend 0 du stock, reste 20 en stock !
Client 1 prend 0 du stock, reste 20 en stock !
Client 1 prend 5 du stock, reste 15 en stock !
Client 3 prend 5 du stock, reste 10 en stock !
Client 3 prend 3 du stock, reste 7 en stock !
Client 4 prend 3 du stock, reste 4 en stock !
Client 0 prend 0 du stock, reste 4 en stock !
Client 2 prend 0 du stock, reste 4 en stock !
Client 3 prend 3 du stock, reste 1 en stock !
Client 1 prend 3 du stock, reste -2 en stock !
Client 4 prend 2 du stock, reste -4 en stock !
Client 0 prend 1 du stock, reste -5 en stock !
Remplissage du stock de 20 articles !
Client 2 prend 3 du stock, reste 17 en stock !
Client 2 prend 3 du stock, reste 14 en stock !
Client 3 prend 2 du stock, reste 12 en stock !
Client 1 prend 1 du stock, reste 11 en stock !
Client 1 prend 0 du stock, reste 11 en stock !
Client 1 prend 2 du stock, reste 9 en stock !

&lt;CTRL-C&gt;
</code></pre></div></div></td></tr></tbody></table></div>

			<div class="paragraph">
				Et la charge CPU utilisée durant le déroulement du processus et ses threads :
			</div><br>

			<div class="image" style="text-align: center;"><img src="pthread_init_files/cpu-exemple-2.png" alt=""><div style="text-align: center;" class="legimage">Charge CPU de l'exemple 2</div></div>
		

		<br><h2 class="TitreSection1" id="LVIII-C">VIII-C. Observations</h2>
			

			<div class="paragraph">
				Il n'y a pas à vrai dire, de changement radical par rapport à l'affichage du résultat sur 
				la sortie console mais nous avons néanmoins protégé l'accès aux données, ce 
				qui fait un risque en moins. Bien sûr, ce programme d'exemple n'est pas un programme critique 
				mais sur d'autres applications cela peut avoir des effets désastreux !
				<br><br>
				Nous pouvons également remarquer que la charge CPU reste inchangée, le programme prend 
				presque toutes les ressources disponibles du processeur. Pour pallier à ce problème, nous pouvons 
				mettre des threads en attente jusqu'à ce que des conditions de réveil soient remplies ! Nous allons 
				donc étudier dans la partie suivante, les <b><i>conditions</i></b> !
			</div><br>
		
	

	<br><h1 class="TitreSection0" id="LIX">IX. Les conditions</h1>
		

		<div class="paragraph">
			Les conditions sont un autre mécanisme de synchronisation, le principe est simple. Lorsqu'un thread doit 
			attendre une condition (comme dans notre exemple, le thread du magasin doit attendre que le stock ne suffise 
			plus aux clients pour le renflouer) pour exécuter sa tâche, nous pouvons le mettre en attente. Un autre thread qui 
			possède le verrou réveille alors le thread dormant lorsque la condition est remplie. Tous les threads ne sont pas des 
			boucles infinies, certains sont créés juste pour faire une action précise puis sont automatiquement détruits mais pour 
			d'autres, comme notre exemple,  les conditions sont un atout dans la consommation des ressources car l'attente d'une 
			condition met systématiquement le thread en pause !
			<br><br>
			Créer une condition repose sur le même principe que les mutex à savoir, la création et initialisation d'une variable de 
			type <b>pthread_cond_t</b> soit par exemple:
		</div>

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e2906"><tbody><tr><td class="code"><div id="codeWrapperd0e2906" class="codeWrapper"><div id="codeOverflowd0e2906" style="overflow: auto;"><pre><code id="contenuCoded0e2906" class="contenuCode"><code class="c_keyword1">static</code> pthread_cond_t cond_stock <code class="c_operator">=</code> PTHREAD_COND_INITIALIZER;
</code></pre></div></div></td></tr></tbody></table></div>

		<div class="paragraph">
			Les conditions reposent essentiellement sur deux fonctions. Une permet de mettre en attente un thread et la 
			seconde permet de signaler que la condition est remplie ce qui réveille alors le thread qui est en attente de cette 
			condition.
		</div><br>

		<table class="infobulle" style="border: 0pt none ; width: 98%; text-align: left;"><tbody><tr><td style="width: 40px; vertical-align: top;" class="colonne"><img src="pthread_init_files/kitidea.gif" alt="idea"></td><td class="colonne">
			Plusieurs threads peuvent surveiller la même condition.
		<br></td></tr></tbody></table>

		<div class="paragraph">
			Les fonctions principales sont les suivantes (elles retournent toutes <b>0</b> mais ne renvoient jamais de code d'erreur) :
		</div><br>

		<br><h2 class="TitreSection1" id="LIX-A">IX-A. pthread_cond_wait</h2>
			

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e2931"><tbody><tr><td class="code"><div id="codeWrapperd0e2931" class="codeWrapper"><div id="codeOverflowd0e2931" style="overflow: auto;"><pre><code id="contenuCoded0e2931" class="contenuCode"><code class="c_keyword3">int</code> pthread_cond_wait (pthread_cond_t <code class="c_operator">*</code> cond, pthread_mutex_t <code class="c_operator">*</code> mutex);
</code></pre></div></div></td></tr></tbody></table></div>

			<div class="paragraph">
				Cette fonction permet de mettre le thread appelant en attente de la condition, il suspend donc son 
				exécution temporairement. Ses deux arguments sont dans l'ordre :
			</div><br>

			<ul style="list-style-type: disc;">
				<li>
					L'adresse de la variable condition de type <b>pthread_cond_t</b>.
				</li>
				<li>
					L'adresse d'un <i>mutex</i>. Une condition est en effet, toujours associée à un mutex.
				</li>
			</ul>
		

		<br><h2 class="TitreSection1" id="LIX-B">IX-B. pthread_cond_signal</h2>
			

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e2966"><tbody><tr><td class="code"><div id="codeWrapperd0e2966" class="codeWrapper"><div id="codeOverflowd0e2966" style="overflow: auto;"><pre><code id="contenuCoded0e2966" class="contenuCode"><code class="c_keyword3">int</code> pthread_cond_signal (pthread_cond_t <code class="c_operator">*</code> cond);
</code></pre></div></div></td></tr></tbody></table></div>

			<div class="paragraph">
				<i>pthread_cond_signal</i> est la fonction qui permet de signaler la condition au thread qui l'attend. 
				Elle prend en paramètre l'adresse de la variable-condition surveillée. Cette fonction ne permet de 
				réveiller qu'un seul thread. Pour en réveiller d'avantage, il faut utiliser la fonction ci-dessous.
			</div><br>
		

		<br><h2 class="TitreSection1" id="LIX-C">IX-C. pthread_cond_broadcast</h2>
			

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e2986"><tbody><tr><td class="code"><div id="codeWrapperd0e2986" class="codeWrapper"><div id="codeOverflowd0e2986" style="overflow: auto;"><pre><code id="contenuCoded0e2986" class="contenuCode"><code class="c_keyword3">int</code> pthread_cond_broadcast (pthread_cond_t <code class="c_operator">*</code> cond);
</code></pre></div></div></td></tr></tbody></table></div>

			<div class="paragraph">
				Comme il l'a été signalé plus haut, plusieurs threads peuvent surveiller la même condition. Cette 
				fonction permet de tous les réveiller. Tout comme <i>pthread_cond_signal</i>, elle prend en 
				paramètre l'adresse de la variable-condition surveillée.
			</div><br>
		
	

	<br><h1 class="TitreSection0" id="LX">X. Mise en pratique</h1>
		

		<div class="paragraph">
			Le raisonnement de notre programme change à partir de maintenant. En effet, prenons le cas d'un client 
			<b>X</b> qui veut prendre <b>N</b> articles du stock du magasin. Si le stock ne suffit pas, le magasin 
			doit le renflouer mais cependant, le client doit attendre que le stock soit suffisant pour satisfaire sa demande.
			<br><br>
			Le client signal donc au magasin qu'il doit remplir à nouveau son stock et en attendant, il se met en attente. Une 
			fois que le magasin a renfloué son stock, il le signal au client en attente et se met à nouveau lui-même en attente 
			jusqu'à ce que la condition soit de nouveau signalée !
			<br><br>
			Quelques changements ont donc eu lieu dans notre programme. Nous avons pour commencer, deux variables-conditions 
			qui viennent s'ajouter à notre structure, une pour les clients et une pour le magasin. La raison en est simple, lorsque le 
			magasin remplit son stock, le client en cours doit attendre que le stock soit à nouveau à un niveau correct, ceci permet 
			d'éviter qu'il descende à un chiffre négatif, nous gardons de ce fait un cheminement logique pour notre programme. Des 
			changements ont aussi été faits sur les deux fonctions <b>fn_store</b> et <b>fn_clients</b>. 
		</div><br>

		<br><h2 class="TitreSection1" id="LX-A">X-A. Fonction : fn_store</h2>
			

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e3033"><tbody><tr><td class="code"><div id="codeWrapperd0e3033" class="codeWrapper"><div id="codeOverflowd0e3033" style="overflow: auto;"><pre><code id="contenuCoded0e3033" class="contenuCode"><code class="c_keyword1">static</code> <code class="c_keyword3">void</code> <code class="c_operator">*</code> fn_store (<code class="c_keyword3">void</code> <code class="c_operator">*</code> p_data)
<code class="c_operator">{</code>
   <code class="c_keyword1">while</code> (<code class="c_digit">1</code>)
   <code class="c_operator">{</code>
      pthread_mutex_lock (<code class="c_operator">&amp;</code> store.mutex_stock);
      pthread_cond_wait (<code class="c_operator">&amp;</code> store.cond_stock, <code class="c_operator">&amp;</code> store.mutex_stock);

      store.stock <code class="c_operator">=</code> INITIAL_STOCK;
      printf (<code class="c_literal1">"</code><code class="c_literal1">Remplissage</code><code class="c_literal1"> </code><code class="c_literal1">du</code><code class="c_literal1"> </code><code class="c_literal1">stock</code><code class="c_literal1"> </code><code class="c_literal1">de</code><code class="c_literal1"> </code><code class="c_literal1">%d</code><code class="c_literal1"> </code><code class="c_literal1">articles</code><code class="c_literal1"> </code><code class="c_literal1">!\n</code><code class="c_literal1">"</code>, store.stock);
      
      pthread_cond_signal (<code class="c_operator">&amp;</code> store.cond_clients);
      pthread_mutex_unlock (<code class="c_operator">&amp;</code> store.mutex_stock);
   <code class="c_operator">}</code>

   <code class="c_keyword1">return</code> <code class="c_literal2">NULL</code>;
<code class="c_operator">}</code>
</code></pre></div></div></td></tr></tbody></table></div>

			<div class="paragraph">
				Le thread attendant que la condition soit remplie pour s'activer, nous n'avons plus besoin du test à l'intérieur 
				de la boucle, nous pouvons donc directement remplir le stock. Nous pouvons voir un processus particulier en ce 
				qui concerne les conditions. En effet, si on regarde le début du corps de la boucle, on peut s'apercevoir que le 
				thread prend le mutex et se met en attente de la condition. En réalité, le thread relâche le mutex aussitôt et 
				le reprend automatiquement lorsque la condition est vraie et qu'il soit réveillé par un autre thread. Lorsque la stock 
				est remplit, la fonction le signale au thread du client courant.
			</div><br>
		

		<br><h2 class="TitreSection1" id="LX-B">X-B. Fonction : fn_clients</h2>
			

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e3132"><tbody><tr><td class="code"><div id="codeWrapperd0e3132" class="codeWrapper"><div id="codeOverflowd0e3132" style="overflow: auto;"><pre><code id="contenuCoded0e3132" class="contenuCode"><code class="c_keyword1">static</code> <code class="c_keyword3">void</code> <code class="c_operator">*</code> fn_clients (<code class="c_keyword3">void</code> <code class="c_operator">*</code> p_data)
<code class="c_operator">{</code>
   <code class="c_keyword3">int</code> nb <code class="c_operator">=</code> (<code class="c_keyword3">int</code>) p_data;

   <code class="c_keyword1">while</code> (<code class="c_digit">1</code>)
   <code class="c_operator">{</code>
      <code class="c_keyword3">int</code> val <code class="c_operator">=</code> get_random (<code class="c_digit">6</code>);


      psleep (get_random (<code class="c_digit">3</code>));
      pthread_mutex_lock (<code class="c_operator">&amp;</code> store.mutex_stock);

      <code class="c_keyword1">if</code> (val <code class="c_operator">&gt;</code> store.stock)
      <code class="c_operator">{</code>
         pthread_cond_signal (<code class="c_operator">&amp;</code> store.cond_stock);
         pthread_cond_wait (<code class="c_operator">&amp;</code> store.cond_clients, <code class="c_operator">&amp;</code> store.mutex_stock);
      <code class="c_operator">}</code>

      store.stock <code class="c_operator">=</code> store.stock <code class="c_operator">-</code> val;
      printf (
         <code class="c_literal1">"</code><code class="c_literal1">Client</code><code class="c_literal1"> </code><code class="c_literal1">%d</code><code class="c_literal1"> </code><code class="c_literal1">prend</code><code class="c_literal1"> </code><code class="c_literal1">%d</code><code class="c_literal1"> </code><code class="c_literal1">du</code><code class="c_literal1"> </code><code class="c_literal1">stock,</code><code class="c_literal1"> </code><code class="c_literal1">reste</code><code class="c_literal1"> </code><code class="c_literal1">%d</code><code class="c_literal1"> </code><code class="c_literal1">en</code><code class="c_literal1"> </code><code class="c_literal1">stock</code><code class="c_literal1"> </code><code class="c_literal1">!\n</code><code class="c_literal1">"</code>,
         nb, val, store.stock
      );

      pthread_mutex_unlock (<code class="c_operator">&amp;</code> store.mutex_stock);
   <code class="c_operator">}</code>

   <code class="c_keyword1">return</code> <code class="c_literal2">NULL</code>;
<code class="c_operator">}</code>
</code></pre></div></div></td></tr></tbody></table></div>

			<div class="paragraph">
				Cette fonction a aussi eu droit à un petit lifting. En effet, un test a été rajouté qui permet de déterminer si 
				le stock est en quantité suffisante par rapport à la demande du client. Si ce n'est pas le cas, le thread le 
				signal au thread du magasin qui prend le relais, le thread appelant ce met en attente le temps que le magasin 
				réalise sa tâche.
			</div><br>
		

		<br><h2 class="TitreSection1" id="LX-C">X-C. Code complet</h2>
			

			<div class="paragraph">
				Exemple numéro 3. Vous pouvez télécharger l'archive <a href="http://franckh.developpez.com/tutoriels/posix/pthreads/sources/pthread-exemple-3.zip" class="lienArticle">ici</a> !
			</div>

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e3289"><tbody><tr><td class="code"><div id="codeWrapperd0e3289" class="codeWrapper"><div id="codeOverflowd0e3289" style="overflow: auto;"><pre><code id="contenuCoded0e3289" class="contenuCode"><code class="c_keyword2">#</code><code class="c_markup">include</code><code class="c_keyword2"> </code><code class="c_keyword2">&lt;stdio.h&gt;</code>
<code class="c_keyword2">#</code><code class="c_markup">include</code><code class="c_keyword2"> </code><code class="c_keyword2">&lt;stdlib.h&gt;</code>
<code class="c_keyword2">#</code><code class="c_markup">include</code><code class="c_keyword2"> </code><code class="c_keyword2">&lt;pthread.h&gt;</code>

<code class="c_keyword2">#</code><code class="c_markup">if</code><code class="c_keyword2"> </code><code class="c_keyword2">defined</code><code class="c_keyword2"> </code><code class="c_keyword2">(</code><code class="c_keyword2">Win32</code><code class="c_keyword2">)</code>
<code class="c_keyword2">#</code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_markup">include</code><code class="c_keyword2"> </code><code class="c_keyword2">&lt;windows.h&gt;</code>
<code class="c_keyword2">#</code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_markup">define</code><code class="c_keyword2"> </code><code class="c_keyword2">psleep</code><code class="c_keyword2">(</code><code class="c_keyword2">sec</code><code class="c_keyword2">)</code><code class="c_keyword2"> </code><code class="c_keyword2">Sleep</code><code class="c_keyword2"> </code><code class="c_keyword2">(</code><code class="c_keyword2">(</code><code class="c_keyword2">sec</code><code class="c_keyword2">)</code><code class="c_keyword2"> </code><code class="c_keyword2">*</code><code class="c_keyword2"> </code><code class="c_digit">1000</code><code class="c_keyword2">)</code>
<code class="c_keyword2">#</code><code class="c_markup">elif</code><code class="c_keyword2"> </code><code class="c_keyword2">defined</code><code class="c_keyword2"> </code><code class="c_keyword2">(</code><code class="c_keyword2">Linux</code><code class="c_keyword2">)</code>
<code class="c_keyword2">#</code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_markup">include</code><code class="c_keyword2"> </code><code class="c_keyword2">&lt;unistd.h&gt;</code>
<code class="c_keyword2">#</code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_markup">define</code><code class="c_keyword2"> </code><code class="c_keyword2">psleep</code><code class="c_keyword2">(</code><code class="c_keyword2">sec</code><code class="c_keyword2">)</code><code class="c_keyword2"> </code><code class="c_keyword2">sleep</code><code class="c_keyword2"> </code><code class="c_keyword2">(</code><code class="c_keyword2">(</code><code class="c_keyword2">sec</code><code class="c_keyword2">)</code><code class="c_keyword2">)</code>
<code class="c_keyword2">#</code><code class="c_markup">endif</code>

<code class="c_keyword2">#</code><code class="c_markup">define</code><code class="c_keyword2"> </code><code class="c_keyword2">INITIAL_STOCK</code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_digit">20</code>
<code class="c_keyword2">#</code><code class="c_markup">define</code><code class="c_keyword2"> </code><code class="c_keyword2">NB_CLIENTS</code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_keyword2"> </code><code class="c_digit">5</code>


<code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Structure</code><code class="c_comment1"> </code><code class="c_comment1">stockant</code><code class="c_comment1"> </code><code class="c_comment1">les</code><code class="c_comment1"> </code><code class="c_comment1">informations</code><code class="c_comment1"> </code><code class="c_comment1">des</code><code class="c_comment1"> </code><code class="c_comment1">threads</code><code class="c_comment1"> </code><code class="c_comment1">clients</code><code class="c_comment1"> </code><code class="c_comment1">et</code><code class="c_comment1"> </code><code class="c_comment1">du</code><code class="c_comment1"> </code><code class="c_comment1">magasin.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
<code class="c_keyword3">typedef</code> <code class="c_keyword3">struct</code>
<code class="c_operator">{</code>
   <code class="c_keyword3">int</code> stock;

   pthread_t thread_store;
   pthread_t thread_clients [NB_CLIENTS];

   pthread_mutex_t mutex_stock;
   pthread_cond_t cond_stock;
   pthread_cond_t cond_clients;
<code class="c_operator">}</code>
store_t;

<code class="c_keyword1">static</code> store_t store <code class="c_operator">=</code>
<code class="c_operator">{</code>
   .stock <code class="c_operator">=</code> INITIAL_STOCK,
   .mutex_stock <code class="c_operator">=</code> PTHREAD_MUTEX_INITIALIZER,
   .cond_stock <code class="c_operator">=</code> PTHREAD_COND_INITIALIZER,
   .cond_clients <code class="c_operator">=</code> PTHREAD_COND_INITIALIZER,
<code class="c_operator">}</code>;


<code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Fonction</code><code class="c_comment1"> </code><code class="c_comment1">pour</code><code class="c_comment1"> </code><code class="c_comment1">tirer</code><code class="c_comment1"> </code><code class="c_comment1">un</code><code class="c_comment1"> </code><code class="c_comment1">nombre</code><code class="c_comment1"> </code><code class="c_comment1">au</code><code class="c_comment1"> </code><code class="c_comment1">sort</code><code class="c_comment1"> </code><code class="c_comment1">entre</code><code class="c_comment1"> </code><code class="c_comment1">0</code><code class="c_comment1"> </code><code class="c_comment1">et</code><code class="c_comment1"> </code><code class="c_comment1">max.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
<code class="c_keyword1">static</code> <code class="c_keyword3">int</code> get_random (<code class="c_keyword3">int</code> max)
<code class="c_operator">{</code>
   <code class="c_keyword3">double</code> val;

   val <code class="c_operator">=</code> (<code class="c_keyword3">double</code>) max <code class="c_operator">*</code> rand ();
   val <code class="c_operator">=</code> val <code class="c_operator">/</code> (RAND_MAX <code class="c_operator">+</code> <code class="c_digit">1</code>.<code class="c_digit">0</code>);

   <code class="c_keyword1">return</code> ((<code class="c_keyword3">int</code>) val);
<code class="c_operator">}</code>


<code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Fonction</code><code class="c_comment1"> </code><code class="c_comment1">pour</code><code class="c_comment1"> </code><code class="c_comment1">le</code><code class="c_comment1"> </code><code class="c_comment1">thread</code><code class="c_comment1"> </code><code class="c_comment1">du</code><code class="c_comment1"> </code><code class="c_comment1">magasin.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
<code class="c_keyword1">static</code> <code class="c_keyword3">void</code> <code class="c_operator">*</code> fn_store (<code class="c_keyword3">void</code> <code class="c_operator">*</code> p_data)
<code class="c_operator">{</code>
   <code class="c_keyword1">while</code> (<code class="c_digit">1</code>)
   <code class="c_operator">{</code>
      <code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Debut</code><code class="c_comment1"> </code><code class="c_comment1">de</code><code class="c_comment1"> </code><code class="c_comment1">la</code><code class="c_comment1"> </code><code class="c_comment1">zone</code><code class="c_comment1"> </code><code class="c_comment1">protegee.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
      pthread_mutex_lock (<code class="c_operator">&amp;</code> store.mutex_stock);
      pthread_cond_wait (<code class="c_operator">&amp;</code> store.cond_stock, <code class="c_operator">&amp;</code> store.mutex_stock);

      store.stock <code class="c_operator">=</code> INITIAL_STOCK;
      printf (<code class="c_literal1">"</code><code class="c_literal1">Remplissage</code><code class="c_literal1"> </code><code class="c_literal1">du</code><code class="c_literal1"> </code><code class="c_literal1">stock</code><code class="c_literal1"> </code><code class="c_literal1">de</code><code class="c_literal1"> </code><code class="c_literal1">%d</code><code class="c_literal1"> </code><code class="c_literal1">articles</code><code class="c_literal1"> </code><code class="c_literal1">!\n</code><code class="c_literal1">"</code>, store.stock);
      
      pthread_cond_signal (<code class="c_operator">&amp;</code> store.cond_clients);
      pthread_mutex_unlock (<code class="c_operator">&amp;</code> store.mutex_stock);
      <code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Fin</code><code class="c_comment1"> </code><code class="c_comment1">de</code><code class="c_comment1"> </code><code class="c_comment1">la</code><code class="c_comment1"> </code><code class="c_comment1">zone</code><code class="c_comment1"> </code><code class="c_comment1">protegee.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
   <code class="c_operator">}</code>

   <code class="c_keyword1">return</code> <code class="c_literal2">NULL</code>;
<code class="c_operator">}</code>


<code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Fonction</code><code class="c_comment1"> </code><code class="c_comment1">pour</code><code class="c_comment1"> </code><code class="c_comment1">les</code><code class="c_comment1"> </code><code class="c_comment1">threads</code><code class="c_comment1"> </code><code class="c_comment1">des</code><code class="c_comment1"> </code><code class="c_comment1">clients.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
<code class="c_keyword1">static</code> <code class="c_keyword3">void</code> <code class="c_operator">*</code> fn_clients (<code class="c_keyword3">void</code> <code class="c_operator">*</code> p_data)
<code class="c_operator">{</code>
   <code class="c_keyword3">int</code> nb <code class="c_operator">=</code> (<code class="c_keyword3">int</code>) p_data;

   <code class="c_keyword1">while</code> (<code class="c_digit">1</code>)
   <code class="c_operator">{</code>
      <code class="c_keyword3">int</code> val <code class="c_operator">=</code> get_random (<code class="c_digit">6</code>);


      psleep (get_random (<code class="c_digit">3</code>));
      
      <code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Debut</code><code class="c_comment1"> </code><code class="c_comment1">de</code><code class="c_comment1"> </code><code class="c_comment1">la</code><code class="c_comment1"> </code><code class="c_comment1">zone</code><code class="c_comment1"> </code><code class="c_comment1">protegee.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
      pthread_mutex_lock (<code class="c_operator">&amp;</code> store.mutex_stock);

      <code class="c_keyword1">if</code> (val <code class="c_operator">&gt;</code> store.stock)
      <code class="c_operator">{</code>
         pthread_cond_signal (<code class="c_operator">&amp;</code> store.cond_stock);
         pthread_cond_wait (<code class="c_operator">&amp;</code> store.cond_clients, <code class="c_operator">&amp;</code> store.mutex_stock);
      <code class="c_operator">}</code>

      store.stock <code class="c_operator">=</code> store.stock <code class="c_operator">-</code> val;
      printf (
         <code class="c_literal1">"</code><code class="c_literal1">Client</code><code class="c_literal1"> </code><code class="c_literal1">%d</code><code class="c_literal1"> </code><code class="c_literal1">prend</code><code class="c_literal1"> </code><code class="c_literal1">%d</code><code class="c_literal1"> </code><code class="c_literal1">du</code><code class="c_literal1"> </code><code class="c_literal1">stock,</code><code class="c_literal1"> </code><code class="c_literal1">reste</code><code class="c_literal1"> </code><code class="c_literal1">%d</code><code class="c_literal1"> </code><code class="c_literal1">en</code><code class="c_literal1"> </code><code class="c_literal1">stock</code><code class="c_literal1"> </code><code class="c_literal1">!\n</code><code class="c_literal1">"</code>,
         nb, val, store.stock
      );

      pthread_mutex_unlock (<code class="c_operator">&amp;</code> store.mutex_stock);
      <code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Fin</code><code class="c_comment1"> </code><code class="c_comment1">de</code><code class="c_comment1"> </code><code class="c_comment1">la</code><code class="c_comment1"> </code><code class="c_comment1">zone</code><code class="c_comment1"> </code><code class="c_comment1">protegee.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
   <code class="c_operator">}</code>

   <code class="c_keyword1">return</code> <code class="c_literal2">NULL</code>;
<code class="c_operator">}</code>


<code class="c_keyword3">int</code> main (<code class="c_keyword3">void</code>)
<code class="c_operator">{</code>
   <code class="c_keyword3">int</code> i <code class="c_operator">=</code> <code class="c_digit">0</code>;
   <code class="c_keyword3">int</code> ret <code class="c_operator">=</code> <code class="c_digit">0</code>;


   <code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Creation</code><code class="c_comment1"> </code><code class="c_comment1">des</code><code class="c_comment1"> </code><code class="c_comment1">threads.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
   printf (<code class="c_literal1">"</code><code class="c_literal1">Creation</code><code class="c_literal1"> </code><code class="c_literal1">du</code><code class="c_literal1"> </code><code class="c_literal1">thread</code><code class="c_literal1"> </code><code class="c_literal1">du</code><code class="c_literal1"> </code><code class="c_literal1">magasin</code><code class="c_literal1"> </code><code class="c_literal1">!\n</code><code class="c_literal1">"</code>);
   ret <code class="c_operator">=</code> pthread_create (
      <code class="c_operator">&amp;</code> store.thread_store, <code class="c_literal2">NULL</code>,
      fn_store, <code class="c_literal2">NULL</code>
   );

   <code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Creation</code><code class="c_comment1"> </code><code class="c_comment1">des</code><code class="c_comment1"> </code><code class="c_comment1">threads</code><code class="c_comment1"> </code><code class="c_comment1">des</code><code class="c_comment1"> </code><code class="c_comment1">clients</code><code class="c_comment1"> </code><code class="c_comment1">si</code><code class="c_comment1"> </code><code class="c_comment1">celui</code><code class="c_comment1"> </code><code class="c_comment1">du</code><code class="c_comment1"> </code><code class="c_comment1">magasinn</code><code class="c_comment1"> </code><code class="c_comment1">a</code><code class="c_comment1"> </code><code class="c_comment1">reussi.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
   <code class="c_keyword1">if</code> (<code class="c_operator">!</code> ret)
   <code class="c_operator">{</code>
      printf (<code class="c_literal1">"</code><code class="c_literal1">Creation</code><code class="c_literal1"> </code><code class="c_literal1">des</code><code class="c_literal1"> </code><code class="c_literal1">threads</code><code class="c_literal1"> </code><code class="c_literal1">clients</code><code class="c_literal1"> </code><code class="c_literal1">!\n</code><code class="c_literal1">"</code>);
      <code class="c_keyword1">for</code> (i <code class="c_operator">=</code> <code class="c_digit">0</code>; i <code class="c_operator">&lt;</code> NB_CLIENTS; i<code class="c_operator">+</code><code class="c_operator">+</code>)
      <code class="c_operator">{</code>
         ret <code class="c_operator">=</code> pthread_create (
            <code class="c_operator">&amp;</code> store.thread_clients [i], <code class="c_literal2">NULL</code>,
            fn_clients, (<code class="c_keyword3">void</code> <code class="c_operator">*</code>) i);

         <code class="c_keyword1">if</code> (ret)
         <code class="c_operator">{</code>
            fprintf (stderr, <code class="c_literal1">"</code><code class="c_literal1">%s</code><code class="c_literal1">"</code>, strerror (ret));
         <code class="c_operator">}</code>
      <code class="c_operator">}</code>
   <code class="c_operator">}</code>
   <code class="c_keyword1">else</code>
   <code class="c_operator">{</code>
      fprintf (stderr, <code class="c_literal1">"</code><code class="c_literal1">%s</code><code class="c_literal1">"</code>, strerror (ret));
   <code class="c_operator">}</code>


   <code class="c_comment1">/*</code><code class="c_comment1"> </code><code class="c_comment1">Attente</code><code class="c_comment1"> </code><code class="c_comment1">de</code><code class="c_comment1"> </code><code class="c_comment1">la</code><code class="c_comment1"> </code><code class="c_comment1">fin</code><code class="c_comment1"> </code><code class="c_comment1">des</code><code class="c_comment1"> </code><code class="c_comment1">threads.</code><code class="c_comment1"> </code><code class="c_comment1">*/</code>
   i <code class="c_operator">=</code> <code class="c_digit">0</code>;
   <code class="c_keyword1">for</code> (i <code class="c_operator">=</code> <code class="c_digit">0</code>; i <code class="c_operator">&lt;</code> NB_CLIENTS; i<code class="c_operator">+</code><code class="c_operator">+</code>)
   <code class="c_operator">{</code>
      pthread_join (store.thread_clients [i], <code class="c_literal2">NULL</code>);
   <code class="c_operator">}</code>
   pthread_join (store.thread_store, <code class="c_literal2">NULL</code>);


   <code class="c_keyword1">return</code> EXIT_SUCCESS;
<code class="c_operator">}</code>
</code></pre></div></div></td></tr></tbody></table></div>

			<table class="infobulle" style="border: 0pt none ; width: 98%; text-align: left;"><tbody><tr><td style="width: 40px; vertical-align: top;" class="colonne"><img src="pthread_init_files/kitwarning.gif" alt="warning"></td><td class="colonne">
				L'exemple de code ci-dessus utilise une variable globale ! Ici ce n'est qu'à titre d'exemple mais je 
				vous encourage à éviter ce genre de pratique autant que possible !
			<br></td></tr></tbody></table>
		

		<br><h2 class="TitreSection1" id="LX-D">X-D. Sortie du programme</h2>
			

			<div class="paragraph">
				Voici la sortie du programme sur la console avec annulation utilisateur :
			</div>

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e4409"><tbody><tr><td class="code"><div id="codeWrapperd0e4409" class="codeWrapper"><div id="codeOverflowd0e4409" style="overflow: auto;"><pre><code id="contenuCoded0e4409" class="contenuCode">Creation du thread du magasin !
Creation des threads clients !
Client 2 prend 5 du stock, reste 15 en stock !
Client 0 prend 5 du stock, reste 10 en stock !
Client 3 prend 1 du stock, reste 9 en stock !
Client 4 prend 2 du stock, reste 7 en stock !
Client 1 prend 4 du stock, reste 3 en stock !
Client 0 prend 2 du stock, reste 1 en stock !
Client 0 prend 0 du stock, reste 1 en stock !
Remplissage du stock de 20 articles !
Client 2 prend 2 du stock, reste 18 en stock !
Client 1 prend 0 du stock, reste 18 en stock !
Client 1 prend 0 du stock, reste 18 en stock !
Client 1 prend 5 du stock, reste 13 en stock !
Client 2 prend 0 du stock, reste 13 en stock !
Client 1 prend 3 du stock, reste 10 en stock !
Client 3 prend 5 du stock, reste 5 en stock !
Client 4 prend 3 du stock, reste 2 en stock !
Client 0 prend 0 du stock, reste 2 en stock !
Remplissage du stock de 20 articles !
Client 1 prend 3 du stock, reste 17 en stock !
Client 2 prend 3 du stock, reste 14 en stock !
Client 3 prend 2 du stock, reste 12 en stock !
Client 4 prend 1 du stock, reste 11 en stock !
Client 0 prend 3 du stock, reste 8 en stock !
Client 2 prend 1 du stock, reste 7 en stock !
Client 2 prend 3 du stock, reste 4 en stock !
Client 1 prend 2 du stock, reste 2 en stock !
Client 0 prend 0 du stock, reste 2 en stock !
Client 0 prend 2 du stock, reste 0 en stock !
Remplissage du stock de 20 articles !
Client 1 prend 5 du stock, reste 15 en stock !
Client 2 prend 1 du stock, reste 14 en stock !
Client 3 prend 4 du stock, reste 10 en stock !
Client 4 prend 0 du stock, reste 10 en stock !

&lt;CTRL-C&gt;
</code></pre></div></div></td></tr></tbody></table></div>

			<div class="paragraph">
				Et la charge CPU utilisée durant le déroulement du processus et ses threads :
			</div><br>

			<div class="image" style="text-align: center;"><img src="pthread_init_files/cpu-exemple-3.png" alt=""><div style="text-align: center;" class="legimage">Charge CPU de l'exemple 3</div></div>
		

		<br><h2 class="TitreSection1" id="LX-E">X-E. Observations</h2>
			

			<div class="paragraph">
				Hormis les changements importants dans notre programme d'exemple, on peut apercevoir que maintenant 
				dans le graphique de la charge CPU, les ressources sont utilisées de façon raisonnable. Ceci est dû au fait 
				que le thread du magasin soit mis en attente et ne tourne donc plus en continu tout le long de la durée de 
				vie du programme, les conditions peuvent donc jouer un rôle important dans ce domaine !
				<br><br>
				On peut également voir sur la sortie console que le stock ne descend plus à une valeur en-dessous de zéro.
			</div><br>
		
	

	<br><h1 class="TitreSection0" id="LXI">XI. Test des threads</h1>
		

		<div class="paragraph">
			Il existe des fonctions permettant de tester des threads entre eux. Les threads étant des types opaques, il est 
			recommandé de les utiliser ! Nous avons à disposition, par exemple, une fonction pour réaliser un test d'égalité entre deux 
			identifiants de threads ou même récupérer l'identifiant d'un thread. Voici ces deux fonctions qui peuvent 
			avoir leur utilité :
		</div><br>

		<br><h2 class="TitreSection1" id="LXI-A">XI-A. pthread_equal</h2>
			

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e4444"><tbody><tr><td class="code"><div id="codeWrapperd0e4444" class="codeWrapper"><div id="codeOverflowd0e4444" style="overflow: auto;"><pre><code id="contenuCoded0e4444" class="contenuCode"><code class="c_keyword3">int</code> pthread_equal (pthread_t thread1, pthread_t thread2);
</code></pre></div></div></td></tr></tbody></table></div>

			<div class="paragraph">
				Cette fonction teste l'égalité entre deux identifiants de threads passés en argument. 
				La fonction renvoie <b>0</b> si les deux threads sont différents, une valeur non nulle s'il sont identiques.
			</div><br>
		

		<br><h2 class="TitreSection1" id="LXI-B">XI-B. pthread_self</h2>
			

<div style="text-align: center;"><table style="margin: 10px auto; width: 90%; border-collapse: collapse;" id="codeTabled0e4461"><tbody><tr><td class="code"><div id="codeWrapperd0e4461" class="codeWrapper"><div id="codeOverflowd0e4461" style="overflow: auto;"><pre><code id="contenuCoded0e4461" class="contenuCode">pthread_t pthread_self (<code class="c_keyword3">void</code>);
</code></pre></div></div></td></tr></tbody></table></div>

			<div class="paragraph">
				Cette fonction retourne l'identifiant du thread appelant.
			</div><br>
		
	

	<br><h1 class="TitreSection0" id="LXII">XII. Conclusion</h1>
		

		<div class="paragraph">
			Nous avons vu dans ce tutoriel comment créer des threads, que sont les mutex et les conditions et comment les utiliser. 
			Nous avons aussi parcouru en vitesse quelques fonctions supplémentaires. Ceci n'est bien sûr qu'un petit avant-goût de la 
			bibliothèque Pthreads, des ouvrages complets sur ce thème existent, notamment :
			<br><br>
			<img src="pthread_init_files/kiten.jpg" alt="en">&nbsp;<a href="http://www.oreilly.com/catalog/pthread/index.html#top" class="lienArticle">PThreads Programming</a>
			<br><br>
			Il n'existe malheureusement pas de livres en français ! Vous pouvez néanmoins poser vos questions sur le forum 
			<a href="http://www.developpez.net/forums/forumdisplay.php?f=18" class="lienArticle">C</a> de 
			<a href="http://www.developpez.com/" class="lienArticle">developpez.com</a> ;)
		</div><br>
	

	<br><h1 class="TitreSection0" id="LXIII">XIII. Remerciements</h1>
		

		<div class="paragraph">
			Un très grand merci à 
			<a href="http://www.developpez.net/forums/member.php?u=67052" class="lienArticle">Alp</a>, 
			<a href="http://www.developpez.net/forums/member.php?u=103584" class="lienArticle">millie</a>, 
			<a href="http://www.developpez.net/forums/member.php?u=57639" class="lienArticle">Skyrunner</a> 
			pour leur avis et suggestions ainsi qu'à 
			<a href="http://www.developpez.net/forums/member.php?u=50863" class="lienArticle">Guardian</a> et 
			<a href="http://www.developpez.net/forums/member.php?u=116373" class="lienArticle"> RideKick</a> 
			pour la relecture et correction de ce tutoriel !
		</div><br>
	
<br><hr><p style="text-align: center;" class="cachee"><a href="http://validator.w3.org/check?uri=referer"><img src="pthread_init_files/valid-xhtml11" alt="Valid XHTML 1.1!" height="31" width="88"></a><a href="http://jigsaw.w3.org/css-validator/check/referer"><img style="border: 0pt none ; width: 88px; height: 31px;" src="pthread_init_files/vcss" alt="Valid CSS!"></a></p>
</div>

<div align="center">
<!-- phpmyvisites -->
<a href="http://www.phpmyvisites.net/" title="phpMyVisites | Open source web analytics" onclick="window.open(this.href);return(false);"><script type="text/javascript">
<!--
var a_vars = Array();
var pagename='initiation-pthreads';

var phpmyvisitesSite = 60;
var phpmyvisitesURL = "http://visites02.developpez.com/phpmyvisites.php";
//-->
</script>
<script type="text/javascript" src="pthread_init_files/phpmyvisites.js"></script><img src="pthread_init_files/phpmyvisites.php" alt="phpMyVisites" style="border: 0pt none ;">

<noscript><p>phpMyVisites | Open source web analytics
<img src="http://visites02.developpez.com/phpmyvisites.php" alt="Statistics" style="border:0" />
</p></noscript></a>
<!-- /phpmyvisites --> 
</div>

<p class="licence">Copyright © 2007 Franck Hecht. Aucune reproduction, même partielle, ne peut être faite 
de ce site et de l'ensemble de son contenu : textes, documents, images, etc 
sans l'autorisation expresse de l'auteur. 
Sinon vous encourez selon la loi jusqu'à 3 ans de prison et jusqu'à 300&nbsp;000&nbsp;E 
de dommages et intérêts. 
Cette page est déposée à la 
<a href="http://www.sacd.fr/" onclick="window.open(this.href); return false;">SACD</a>.</p>        
</td></tr>
       <tr>
       <td class="trbleu cachee">
         Responsable bénévole de la rubrique <b>C</b> :         <a href="http://www.developpez.net/forums/member.php?u=71378" class="narub" onclick="window.open(this.href); return false;">Arnaud Feltz (buchs)</a>         - Contacter par EMail :
          <script type="text/javascript">
          <!--
          Ch=new Array(4);Res=new Array(4);
          Ch[0]='le_club_des_developeur';Ch[1]='ÙÆÈÏàä';
          Ch[2]='¬×ÄÇÍØÖÈÓÓ';Ch[3]='ÐÊÕÈØäÒÏÉß¡ÂÓÒ';
          for(y=1;y<4;y++){Res[y]="";for(x=0;x<Ch[y].length;x++)
          Res[y]+=String.fromCharCode(Ch[y].charCodeAt(x)-Ch[0].charCodeAt(x));}
          document.write('<a href="'+Res[1]+':c'+Res[2]+'-'+Res[3]+'" class="narub">c'+Res[2]+'-'+Res[3]+'</a>');
          //-->
          </script><a href="mailto:c@redaction-developpez.com" class="narub">c@redaction-developpez.com</a></td></tr>

     </tbody></table>
    </td>
   </tr>
   </tbody></table>
   </td>
  </tr>
  <tr>
    <td>
      <table class="cachee" cellpadding="4" width="100%">
      <tbody><tr>
        <td class="titrepied" align="center">
          Vos questions techniques : <b><a href="http://www.developpez.net/forums/forumdisplay.php?f=7" onclick="window.open(this.href); return false;">forum d'entraide C</a></b> - Publiez vos articles, tutoriels et cours<br>
          et rejoignez-nous dans l'équipe de rédaction du club d'entraide des développeurs francophones <br> <a href="http://club.developpez.com/contacts/">Nous contacter</a>
          - Copyright © 2000-2008 www.developpez.com -           <a href="http://www.developpez.com/legal/">Legal informations</a>.        </td>
    <td align="center">
<a href="http://www.xiti.com/xiti.asp?s=123861" title="Mesurez votre audience">
<script type="text/javascript">
<!--
Xt_param = 's=123861&p=';
Xt_r = document.referrer;
Xt_h = new Date();
Xt_i = '<img width="39" height="25" border="0" ';
Xt_i += 'src="http://logv23.xiti.com/hit.xiti?'+Xt_param;
Xt_i += '&hl='+Xt_h.getHours()+'x'+Xt_h.getMinutes()+'x'+Xt_h.getSeconds();
if(parseFloat(navigator.appVersion)>=4)
{Xt_s=screen;Xt_i+='&r='+Xt_s.width+'x'+Xt_s.height+'x'+Xt_s.pixelDepth+'x'+Xt_s.colorDepth;}
document.write(Xt_i+'&ref='+Xt_r.replace(/[<>"]/g, '').replace(/&/g, '$')+'" title="Analyse d\'audience">');
//-->
</script><img style="display: none;" src="pthread_init_files/hit" title="Analyse d'audience" border="0" height="25" width="39">
<object>
<noscript>
<div>
Mesure d'audience ROI frequentation par <img width="39" height="25"
src="http://logv23.xiti.com/hit.xiti?s=123861&amp;p=" alt="Analyse
d'audience" />
</div>
</noscript>
</object>
</a>
      <script type="text/javascript">
      <!--
      xtn2 = "5";
      //-->
      </script>
    
<br>
<script type="text/javascript"> 
<!-- 
xtnv = document;
xtsd = "http://logc15"; 
xtsite = "203548"; 
xtpage = "";
xtdmc = "";
xtprm = "";
//--> 
</script> 
<script type="text/javascript" src="pthread_init_files/xtexpert.js"></script><img style="display: none;" src="pthread_init_files/hit_002" height="1" width="1"> 
<noscript> 
<div>
<img width="1" alt="" height="1" src="http://logc15.xiti.com/hit.xiti?s=203548&amp;p=&amp;" /> 
</div>
</noscript>
                     
        </td>       
      </tr>
      </tbody></table>
    </td>
  </tr>
  </tbody></table>
</body></html>